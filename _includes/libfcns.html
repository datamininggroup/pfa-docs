<div id="lib:" class="PFAhead"><h2>core</h2></div>
<div id="fcn:+" class="PFAfcndef">
{<b>"+":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Add <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
<p><b>Details:</b><ul><li>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or NaN values.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Integer results above or below -2147483648 and 2147483647 (inclusive) produce an "int overflow" runtime error.</li><li>Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:-" class="PFAfcndef">
{<b>"-":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Subtract <span class="PFAp">y</span> from <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or NaN values.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Integer results above or below -2147483648 and 2147483647 (inclusive) produce an "int overflow" runtime error.</li><li>Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:*" class="PFAfcndef">
{<b>"*":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Multiply <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
<p><b>Details:</b><ul><li>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or NaN values.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Integer results above or below -2147483648 and 2147483647 (inclusive) produce an "int overflow" runtime error.</li><li>Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:/" class="PFAfcndef">
{<b>"/":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>y</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Divide <span class="PFAp">y</span> from <span class="PFAp">x</span>, returning a floating-point number (even if <span class="PFAp">x</span> and <span class="PFAp">y</span> are integers).</p>
</div>
<div id="fcn://" class="PFAfcndef">
{<b>"//":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long}</td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Divide <span class="PFAp">y</span> from <span class="PFAp">x</span>, returning the largest whole number <span class="PFAc">N</span> for which <span class="PFAc">N</span> ≤ <span class="PFAp">x</span>/<span class="PFAp">y</span> (integral floor division).</p>
</div>
<div id="fcn:u-" class="PFAfcndef">
{<b>"u-":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the additive inverse of <span class="PFAp">x</span>.</p>
<p><b>Runtime Errors:</b><ul><li>For exactly one integer value, -2147483648, this function produces an "int overflow" runtime error.</li><li>For exactly one long value, -9223372036854775808, this function produces a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:%" class="PFAfcndef">
{<b>"%":</b> [k, n]} <br><table class="PFAwhere"><tr><td><b>k</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>n</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return <span class="PFAp">k</span> modulo <span class="PFAp">n</span>; the result has the same sign as the modulus <span class="PFAp">n</span>.</p>
<p><b>Details:</b><ul><li>This is the behavior of the <span class="PFAc">%</span> operator in Python, <span class="PFAc">mod</span>/<span class="PFAc">modulo</span> in Ada, Haskell, and Scheme.</li></ul></p>
</div>
<div id="fcn:%%" class="PFAfcndef">
{<b>"%%":</b> [k, n]} <br><table class="PFAwhere"><tr><td><b>k</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>n</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the remainder of <span class="PFAp">k</span> divided by <span class="PFAp">n</span>; the result has the same sign as the dividend <span class="PFAp">k</span>.</p>
<p><b>Details:</b><ul><li>This is the behavior of the <span class="PFAc">%</span> operator in Fortran, C/C++, and Java, <span class="PFAc">rem</span>/<span class="PFAc">remainder</span> in Ada, Haskell, and Scheme.</li></ul></p>
</div>
<div id="fcn:**" class="PFAfcndef">
{<b>"**":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Raise <span class="PFAp">x</span> to the power <span class="PFAp">n</span>.</p>
<p><b>Details:</b><ul><li>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or NaN values.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Integer results above or below -2147483648 and 2147483647 (inclusive) produce an "int overflow" runtime error.</li><li>Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:cmp" class="PFAfcndef">
{<b>"cmp":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">1</span> if <span class="PFAp">x</span> is greater than <span class="PFAp">y</span>, <span class="PFAc">-1</span> if <span class="PFAp">x</span> is less than <span class="PFAp">y</span>, and <span class="PFAc">0</span> if <span class="PFAp">x</span> and <span class="PFAp">y</span> are equal.</p>
</div>
<div id="fcn:==" class="PFAfcndef">
{<b>"==":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is equal to <span class="PFAp">y</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:>=" class="PFAfcndef">
{<b>">=":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is greater than or equal to <span class="PFAp">y</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:>" class="PFAfcndef">
{<b>">":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is greater than <span class="PFAp">y</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:!=" class="PFAfcndef">
{<b>"!=":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is not equal to <span class="PFAp">y</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:<" class="PFAfcndef">
{<b>"<":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is less than <span class="PFAp">y</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:<=" class="PFAfcndef">
{<b>"<=":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is less than or equal to <span class="PFAp">y</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:max" class="PFAfcndef">
{<b>"max":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return <span class="PFAp">x</span> if <span class="PFAp">x</span> ≥ <span class="PFAp">y</span>, <span class="PFAp">y</span> otherwise.</p>
<p><b>Details:</b><ul><li>For the maximum of more than two values, see <span class="PFAf">a.max</span></li></ul></p>
</div>
<div id="fcn:min" class="PFAfcndef">
{<b>"min":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>y</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return <span class="PFAp">x</span> if <span class="PFAp">x</span> &lt; <span class="PFAp">y</span>, <span class="PFAp">y</span> otherwise.</p>
<p><b>Details:</b><ul><li>For the minimum of more than two values, see <span class="PFAf">a.min</span></li></ul></p>
</div>
<div id="fcn:&&" class="PFAfcndef">
{<b>"&&":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>boolean</td></tr><tr><td><b>y</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> and <span class="PFAp">y</span> are both <span class="PFAc">true</span>, <span class="PFAc">false</span> otherwise.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">x</span> is <span class="PFAc">false</span>, <span class="PFAp">y</span> won't be evaluated.  (Only relevant for arguments with side effects.)</li></ul></p>
</div>
<div id="fcn:||" class="PFAfcndef">
{<b>"||":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>boolean</td></tr><tr><td><b>y</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if either <span class="PFAp">x</span> or <span class="PFAp">y</span> (or both) are <span class="PFAc">true</span>, <span class="PFAc">false</span> otherwise.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">x</span> is <span class="PFAc">true</span>, <span class="PFAp">y</span> won't be evaluated.  (Only relevant for arguments with side effects.)</li></ul></p>
</div>
<div id="fcn:^^" class="PFAfcndef">
{<b>"^^":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>boolean</td></tr><tr><td><b>y</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is <span class="PFAc">true</span> and <span class="PFAp">y</span> is <span class="PFAc">false</span> or if <span class="PFAp">x</span> is <span class="PFAc">false</span> and <span class="PFAp">y</span> is <span class="PFAc">true</span>, but return <span class="PFAc">false</span> for any other case.</p>
</div>
<div id="fcn:!" class="PFAfcndef">
{<b>"!":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is <span class="PFAc">false</span> and <span class="PFAc">false</span> if <span class="PFAp">x</span> is <span class="PFAc">true</span>.</p>
</div>
<div id="fcn:&&&" class="PFAfcndef">
{<b>"&&&":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>union of {boolean, null}</td></tr><tr><td><b>y</b></td><td>union of {boolean, null}</td></tr><tr><td><i>(returns)</i></td><td>union of {boolean, null}</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">false</span> if <span class="PFAp">x</span> or <span class="PFAp">y</span> is <span class="PFAc">false</span>, <span class="PFAc">true</span> if <span class="PFAp">x</span> and <span class="PFAp">y</span> are <span class="PFAc">true</span>, and <span class="PFAc">null</span> otherwise.</p>
<p><b>Details:</b><ul><li>This corresponds to Kleene's three-state logic, in which <span class="PFAc">null</span> represents a boolean quantity whose value is unknown.</li><li>If <span class="PFAp">x</span> is <span class="PFAc">false</span>, <span class="PFAp">y</span> won't be evaluated.  (Only relevant for arguments with side effects.)</li></ul></p>
</div>
<div id="fcn:|||" class="PFAfcndef">
{<b>"|||":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>union of {boolean, null}</td></tr><tr><td><b>y</b></td><td>union of {boolean, null}</td></tr><tr><td><i>(returns)</i></td><td>union of {boolean, null}</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> or <span class="PFAp">y</span> is <span class="PFAc">true</span>, <span class="PFAc">false</span> if both <span class="PFAp">x</span> and <span class="PFAp">y</span> is <span class="PFAc">false</span>, or <span class="PFAc">null</span> otherwise.</p>
<p><b>Details:</b><ul><li>This corresponds to Kleene's three-state logic, in which <span class="PFAc">null</span> represents a boolean quantity whose value is unknown.</li><li>If <span class="PFAp">x</span> is <span class="PFAc">true</span>, <span class="PFAp">y</span> won't be evaluated.  (Only relevant for arguments with side effects.)</li></ul></p>
</div>
<div id="fcn:!!!" class="PFAfcndef">
{<b>"!!!":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>union of {boolean, null}</td></tr><tr><td><i>(returns)</i></td><td>union of {boolean, null}</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is <span class="PFAc">false</span>, <span class="PFAc">false</span> if <span class="PFAp">x</span> is <span class="PFAc">true</span>, or <span class="PFAc">null</span> if <span class="PFAp">x</span> is <span class="PFAc">null</span>.</p>
<p><b>Details:</b><ul><li>This corresponds to Kleene's three-state logic, in which <span class="PFAc">null</span> represents a boolean quantity whose value is unknown.</li></ul></p>
</div>
<div id="fcn:&" class="PFAfcndef">
{<b>"&":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>y</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"&":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>y</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Calculate the bitwise-and of <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
</div>
<div id="fcn:|" class="PFAfcndef">
{<b>"|":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>y</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"|":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>y</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Calculate the bitwise-or of <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
</div>
<div id="fcn:^" class="PFAfcndef">
{<b>"^":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>y</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"^":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>y</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Calculate the bitwise-exclusive-or of <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
</div>
<div id="fcn:~" class="PFAfcndef">
{<b>"~":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"~":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Calculate the bitwise-not of <span class="PFAp">x</span>.</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:m">m</h2></div>
<div id="fcn:m.pi" class="PFAfcndef">
{<b>"m.pi":</b> []} <br><table class="PFAwhere"><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> The double-precision number that is closer than any other to \(\pi\), the ratio of a circumference of a circle to its diameter.</p>
</div>
<div id="fcn:m.e" class="PFAfcndef">
{<b>"m.e":</b> []} <br><table class="PFAwhere"><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> The double-precision number that is closer than any other to \(e\), the base of natural logarithms.</p>
</div>
<div id="fcn:m.abs" class="PFAfcndef">
{<b>"m.abs":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the absolute value of <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>For exactly one integer value, -2147483648, this function produces an "int overflow" runtime error.</li><li>For exactly one long value, -9223372036854775808, this function produces a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:m.acos" class="PFAfcndef">
{<b>"m.acos":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the arc-cosine (inverse of the cosine function) of <span class="PFAp">x</span> as an angle in radians between \(0\) and \(\pi\).</p>
<p><b>Details:</b><ul><li>The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
</div>
<div id="fcn:m.asin" class="PFAfcndef">
{<b>"m.asin":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the arc-sine (inverse of the sine function) of <span class="PFAp">x</span> as an angle in radians between \(-\pi/2\) and \(\pi/2\).</p>
<p><b>Details:</b><ul><li>The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
</div>
<div id="fcn:m.atan" class="PFAfcndef">
{<b>"m.atan":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the arc-tangent (inverse of the tangent function) of <span class="PFAp">x</span> as an angle in radians between \(-\pi/2\) and \(\pi/2\).</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.atan2" class="PFAfcndef">
{<b>"m.atan2":</b> [y, x]} <br><table class="PFAwhere"><tr><td><b>y</b></td><td>double</td></tr><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the arc-tangent (inverse of the tangent function) of <span class="PFAp">y</span>/<span class="PFAp">x</span> without loss of precision for small <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real plane; no pair of inputs is invalid.</li><li>Note that <span class="PFAp">y</span> is the first parameter and <span class="PFAp">x</span> is the second parameter.</li></ul></p>
</div>
<div id="fcn:m.ceil" class="PFAfcndef">
{<b>"m.ceil":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the smallest (closest to negative infinity, not closest to zero) whole number that is greater than or equal to the input.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.copysign" class="PFAfcndef">
{<b>"m.copysign":</b> [mag, sign]} <br><table class="PFAwhere"><tr><td><b>mag</b></td><td>any <b>A</b> of {int, long, float, double}</td></tr><tr><td><b>sign</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return a number with the magnitude of <span class="PFAp">mag</span> and the sign of <span class="PFAp">sign</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real or integer plane; no pair of inputs is invalid.</li></ul></p>
</div>
<div id="fcn:m.cos" class="PFAfcndef">
{<b>"m.cos":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the trigonometric cosine of <span class="PFAp">x</span>, which is assumed to be in radians.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.cosh" class="PFAfcndef">
{<b>"m.cosh":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the hyperbolic cosine of <span class="PFAp">x</span>, which is equal to \(\frac{e^x + e^{-x}}{2}\)</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.exp" class="PFAfcndef">
{<b>"m.exp":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return <span class="PFAf">m.e</span> raised to the power of <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.expm1" class="PFAfcndef">
{<b>"m.expm1":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return \(e^x - 1\).</p>
<p><b>Details:</b><ul><li>Avoids round-off or overflow errors in the intermediate steps.</li><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.floor" class="PFAfcndef">
{<b>"m.floor":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the largest (closest to positive infinity) whole number that is less than or equal to the input.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.hypot" class="PFAfcndef">
{<b>"m.hypot":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>y</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return \(\sqrt{x^2 + y^2}\).</p>
<p><b>Details:</b><ul><li>Avoids round-off or overflow errors in the intermediate steps.</li><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.ln" class="PFAfcndef">
{<b>"m.ln":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the natural logarithm of <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
</div>
<div id="fcn:m.log10" class="PFAfcndef">
{<b>"m.log10":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the logarithm base 10 of <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
</div>
<div id="fcn:m.log" class="PFAfcndef">
{<b>"m.log":</b> [x, base]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>base</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the logarithm of <span class="PFAp">x</span> with a given <span class="PFAp">base</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">base</span> is less than or equal to zero, this function produces a "base must be positive" runtime error.</li></ul></p>
</div>
<div id="fcn:m.ln1p" class="PFAfcndef">
{<b>"m.ln1p":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return \(ln(x^2 + 1)\).</p>
<p><b>Details:</b><ul><li>Avoids round-off or overflow errors in the intermediate steps.</li><li>The domain of this function is from -1 to infinity (exclusive).  Given -1, the result is negative infinity, and below -1, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
</div>
<div id="fcn:m.round" class="PFAfcndef">
{<b>"m.round":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"m.round":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Return the closest whole number to <span class="PFAp">x</span>, rounding up if the fractional part is exactly one-half.</p>
<p><b>Details:</b><ul><li>Equal to <span class="PFAf">m.floor</span> of (<span class="PFAp">x</span> + 0.5).</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Integer results outside of -2147483648 and 2147483647 (inclusive) produce an "int overflow" runtime error.</li><li>Long-integer results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:m.rint" class="PFAfcndef">
{<b>"m.rint":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the closest whole number to <span class="PFAp">x</span>, rounding toward the nearest even number if the fractional part is exactly one-half.</p>
</div>
<div id="fcn:m.signum" class="PFAfcndef">
{<b>"m.signum":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return 0 if <span class="PFAp">x</span> is zero, 1 if <span class="PFAp">x</span> is positive, and -1 if <span class="PFAp">x</span> is negative.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.sin" class="PFAfcndef">
{<b>"m.sin":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the trigonometric sine of <span class="PFAp">x</span>, which is assumed to be in radians.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.sinh" class="PFAfcndef">
{<b>"m.sinh":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the hyperbolic sine of <span class="PFAp">x</span>, which is equal to \(\frac{e^x - e^{-x}}{2}\).</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.sqrt" class="PFAfcndef">
{<b>"m.sqrt":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the positive square root of <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>The domain of this function is from 0 (inclusive) to infinity.  Beyond this domain, the result is <span class="PFAc">NaN</span>, not an exception (see IEEE 754).  Use <span class="PFAf">impute.ensureFinite</span> to produce errors from infinite or <span class="PFAc">NaN</span> values."</li></ul></p>
</div>
<div id="fcn:m.tan" class="PFAfcndef">
{<b>"m.tan":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the trigonometric tangent of <span class="PFAp">x</span>, which is assumed to be in radians.</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="fcn:m.tanh" class="PFAfcndef">
{<b>"m.tanh":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the hyperbolic tangent of <span class="PFAp">x</span>, which is equal to \(\frac{e^x - e^{-x}}{e^x + e^{-x}}\).</p>
<p><b>Details:</b><ul><li>The domain of this function is the whole real line; no input is invalid.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:m.special">m.special</h2></div>
<div id="fcn:m.special.nChooseK" class="PFAfcndef">
{<b>"m.special.nChooseK":</b> [n, k]} <br><table class="PFAwhere"><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>k</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b>  The number of ways to choose <span class="PFAp">k</span> elements from a set of <span class="PFAp">n</span> elements.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>n</b></td><td>Total number of elements.</td></tr>
<tr><td><b>k</b></td><td>Numer of elements chosen.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(n\) and \(k\), this function evaluates the binomial coefficient.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "domain error" if \(k \leq 0\) and \(n \leq k\).</li></ul></p>
</div>
<div id="fcn:m.special.lnBeta" class="PFAfcndef">
{<b>"m.special.lnBeta":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>double</td></tr><tr><td><b>b</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the beta function parameterized by <span class="PFAp">a</span> and <span class="PFAp">b</span>.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(a\) and \(b\), this function evaluates natural logarithm of the beta function. The beta function is \(\int_{0}^{1} t^{a - 1}(1 - t)^{b - 1} dt \).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "domain error" if \(a \leq 0\) or if \(b \leq 0\).</li></ul></p>
</div>
<div id="fcn:m.special.erf" class="PFAfcndef">
{<b>"m.special.erf":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the error function of <span class="PFAp">x</span>.</p>
</div>
<div id="fcn:m.special.erfc" class="PFAfcndef">
{<b>"m.special.erfc":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the complimentary error function of <span class="PFAp">x</span>.</p>
</div>
<div id="fcn:m.special.lnGamma" class="PFAfcndef">
{<b>"m.special.lnGamma":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the natural log of the gamma function of <span class="PFAp">x</span>.</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:m.link">m.link</h2></div>
<div id="fcn:m.link.softmax" class="PFAfcndef">
{<b>"m.link.softmax":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.softmax":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the softmax function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(\exp(x_i)/\sum_j \exp(x_j)\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.logit" class="PFAfcndef">
{<b>"m.link.logit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.logit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.logit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the logit function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(1 / (1 + \exp(-x_i))\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.probit" class="PFAfcndef">
{<b>"m.link.probit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.probit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.probit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the probit function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \((\mbox{erf}(x_i/\sqrt{2}) + 1)/2\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.cloglog" class="PFAfcndef">
{<b>"m.link.cloglog":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.cloglog":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.cloglog":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the cloglog function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(1 - \exp(-\exp(x_i))\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.loglog" class="PFAfcndef">
{<b>"m.link.loglog":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.loglog":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.loglog":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the loglog function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(\exp(-\exp(x_i))\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.cauchit" class="PFAfcndef">
{<b>"m.link.cauchit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.cauchit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.cauchit":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the cauchit function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(0.5 + (1/\pi) \tan^{-1}(x_i)\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.softplus" class="PFAfcndef">
{<b>"m.link.softplus":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.softplus":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.softplus":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the softplus function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(\log(1.0 + \exp(x_i))\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.relu" class="PFAfcndef">
{<b>"m.link.relu":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.relu":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.relu":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the rectified linear unit (ReLu) function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(\log(1.0 + \exp(x_i))\).</td></tr>
</table></p>
</div>
<div id="fcn:m.link.tanh" class="PFAfcndef">
{<b>"m.link.tanh":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"m.link.tanh":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"m.link.tanh":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Normalize a prediction with the hyperbolic tangent function.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Each element \(x_i\) is mapped to \(\tanh(x_i)\).</td></tr>
</table></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:la">la</h2></div>
<div id="fcn:la.map" class="PFAfcndef">
{<b>"la.map":</b> [x, fcn]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>fcn</b></td><td>function of (double) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.map":</b> [x, fcn]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>fcn</b></td><td>function of (double) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element from <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>This can be used to perform scalar multiplication on a matrix: supply a function that multiplies each element by a constant.</li><li>The order in which elements are computed is not specified, and may be in parallel.</li></ul></p>
</div>
<div id="fcn:la.scale" class="PFAfcndef">
{<b>"la.scale":</b> [x, alpha]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"la.scale":</b> [x, alpha]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.scale":</b> [x, alpha]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
{<b>"la.scale":</b> [x, alpha]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Scale vector or matrix <span class="PFAp">x</span> by factor <span class="PFAp">alpha</span>.</p>
<p><b>Details:</b><ul><li>The order in which elements are computed is not specified, and may be in parallel.</li></ul></p>
</div>
<div id="fcn:la.zipmap" class="PFAfcndef">
{<b>"la.zipmap":</b> [x, y, fcn]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>y</b></td><td>array of array of double</td></tr><tr><td><b>fcn</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.zipmap":</b> [x, y, fcn]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>y</b></td><td>map of map of double</td></tr><tr><td><b>fcn</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each pair of elements from <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
<p><b>Details:</b><ul><li>This can be used to perform matrix addition: supply a function that adds each pair of elements.</li><li>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and columns in <span class="PFAp">x</span> must be equal to the number of rows and columns of <span class="PFAp">y</span>, respectively.  In the map signature, missing row-column combinations are assumed to be zero.</li><li>The order in which elements are computed is not specified, and may be in parallel.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>In the array signature, if any element in <span class="PFAp">x</span> does not have a corresponding element in <span class="PFAp">y</span> (or vice-versa), this function raises a "misaligned matrices" error.</li></ul></p>
</div>
<div id="fcn:la.add" class="PFAfcndef">
{<b>"la.add":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>y</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"la.add":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>y</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.add":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><b>y</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
{<b>"la.add":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>y</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Add two vectors or matrices <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
<p><b>Details:</b><ul><li>The order in which elements are computed is not specified, and may be in parallel.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>In the array signature, if any element in <span class="PFAp">x</span> does not have a corresponding element in <span class="PFAp">y</span> (or vice-versa), this function raises a "misaligned matrices" error.</li></ul></p>
</div>
<div id="fcn:la.sub" class="PFAfcndef">
{<b>"la.sub":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>y</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"la.sub":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>y</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.sub":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><b>y</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
{<b>"la.sub":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>y</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Subtract vector or matrix <span class="PFAp">y</span> from <span class="PFAp">x</span> (returns \(x - y\)).</p>
<p><b>Details:</b><ul><li>The order in which elements are computed is not specified, and may be in parallel.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>In the array signature, if any element in <span class="PFAp">x</span> does not have a corresponding element in <span class="PFAp">y</span> (or vice-versa), this function raises a "misaligned matrices" error.</li></ul></p>
</div>
<div id="fcn:la.dot" class="PFAfcndef">
{<b>"la.dot":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>y</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"la.dot":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>y</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
{<b>"la.dot":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>y</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.dot":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>y</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Multiply two matrices or a matrix and a vector, which may be represented as dense arrays or potentially sparse maps.</p>
<p><b>Details:</b><ul><li>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of columns of <span class="PFAp">x</span> must be equal to the number of rows (or the number of elements) of <span class="PFAp">y</span>.  In the map signature, missing values are assumed to be zero.</li><li>Matrices supplied as maps may be computed using sparse methods.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>In the array signature, if the dimensions of <span class="PFAp">x</span> do not correspond to the dimension(s) of <span class="PFAp">y</span>, this function raises a "misaligned matrices" error.</li></ul></p>
</div>
<div id="fcn:la.transpose" class="PFAfcndef">
{<b>"la.transpose":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.transpose":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Transpose a rectangular matrix.</p>
<p><b>Runtime Errors:</b><ul><li>If the matrix has fewer than 1 row or fewer than 1 column, this function raises a "too few rows/cols" error.</li><li>If the columns are ragged (arrays of different lengths or maps with different sets of keys), this function raises a "ragged columns" error.</li></ul></p>
</div>
<div id="fcn:la.inverse" class="PFAfcndef">
{<b>"la.inverse":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.inverse":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Compute the inverse (or Moore-Penrose pseudoinverse, if not square) of <span class="PFAp">x</span>.</p>
<p><b>Runtime Errors:</b><ul><li>If the matrix has fewer than 1 row or fewer than 1 column, this function raises a "too few rows/cols" error.</li><li>If <span class="PFAp">x</span> is an array with ragged columns (arrays of different lengths), this function raises a "ragged columns" error.</li></ul></p>
</div>
<div id="fcn:la.trace" class="PFAfcndef">
{<b>"la.trace":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"la.trace":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the trace of a matrix (sum of diagonal elements).</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">x</span> is an array with ragged columns (arrays of different lengths), this function raises a "ragged columns" error.</li></ul></p>
</div>
<div id="fcn:la.det" class="PFAfcndef">
{<b>"la.det":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"la.det":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the determinant of a matrix.</p>
<p><b>Runtime Errors:</b><ul><li>If the matrix has fewer than 1 row or fewer than 1 column, this function raises a "too few rows/cols" error.</li><li>If <span class="PFAp">x</span> is an array with ragged columns (arrays of different lengths), this function raises a "ragged columns" error.</li><li>In the array signature, if <span class="PFAp">x</span> is not a square matrix, this function raises a "non-square matrix" error.</li></ul></p>
</div>
<div id="fcn:la.symmetric" class="PFAfcndef">
{<b>"la.symmetric":</b> [x, tolerance]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>tolerance</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"la.symmetric":</b> [x, tolerance]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>tolerance</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determine if a matrix is symmetric withing tolerance.</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns <span class="PFAc">true</span> if the absolute value of element \(i\), \(j\) minus element \(j\), \(i\) is less than <span class="PFAp">tolerance</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If the matrix has fewer than 1 row or fewer than 1 column, this function raises a "too few rows/cols" error.</li><li>If <span class="PFAp">x</span> is an array with ragged columns (arrays of different lengths), this function raises a "ragged columns" error.</li><li>If <span class="PFAp">x</span> is not a square matrix, this function raises a "non-square matrix" error.</li></ul></p>
</div>
<div id="fcn:la.eigenBasis" class="PFAfcndef">
{<b>"la.eigenBasis":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.eigenBasis":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Compute the eigenvalues and eigenvectors of a real, symmetric matrix <span class="PFAp">x</span> (which are all real).</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>A matrix in which each row (first level of array or map hierarchy) is a normalized eigenvector of <span class="PFAp">x</span> divided by the square root of the corresponding eigenvalue (The sign is chosen such that the first component is positive.).  If provided as an array, the rows are in decreasing order of eigenvalue (increasing order of inverse square root eigenvalue).  If provided as a map, the rows are keyed by string representations of integers starting with <span class="PFAc">"0"</span>, and increasing row keys are in decreasing order of eigenvalue.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If <span class="PFAp">x</span> is the covariance matrix of a zero-mean dataset, the matrix that this function returns would transform the dataset to one with unit variances and zero covariances.</li><li>If <span class="PFAp">x</span> is not symmetric or not exactly symmetric, it will first be symmetrized (\((x + x^T)/2\)).  For example, a matrix represented by only the upper triangle (other elements are zero or missing from the map) becomes a symmetric matrix with the upper triangle unchanged.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If the matrix has fewer than 1 row or fewer than 1 column, this function raises a "too few rows/cols" error.</li><li>If <span class="PFAp">x</span> is an array with ragged columns (arrays of different lengths), this function raises a "ragged columns" error.</li><li>If <span class="PFAp">x</span> is not a square matrix, this function raises a "non-square matrix" error.</li></ul></p>
</div>
<div id="fcn:la.truncate" class="PFAfcndef">
{<b>"la.truncate":</b> [x, keep]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of array of double</td></tr><tr><td><b>keep</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
{<b>"la.truncate":</b> [x, keep]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of map of double</td></tr><tr><td><b>keep</b></td><td>array of string</td></tr><tr><td><i>(returns)</i></td><td>map of map of double</td></tr></table>
<p><b>Description:</b> Remove rows from a matrix so that it becomes a projection operator.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>The matrix to truncate.</td></tr>
<tr><td><b>keep</b></td><td>If <span class="PFAp">x</span> is an array, this is the number of rows to keep, starting with the first row.  If <span class="PFAp">x</span> is a map, this is the set of keys to keep.  If <span class="PFAp">keep</span> is larger than the number of rows or is not a subset of the keys, the excess is ignored.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>In Principle Component Analysis (PCA), this would be applied to the eigenbasis transformation (<span class="PFAf">la.eigenBasis</span>) to keep only a specified number (or set) of transformed components.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If the matrix has fewer than 1 row or fewer than 1 column, this function raises a "too few rows/cols" error.</li><li>If <span class="PFAp">x</span> is an array with ragged columns (arrays of different lengths), this function raises a "ragged columns" error.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:metric">metric</h2></div>
<div id="fcn:metric.simpleEuclidean" class="PFAfcndef">
{<b>"metric.simpleEuclidean":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>y</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Euclidean metric without a special similarity function and without any handling of missing values.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>First sample vector.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns \(\sqrt{\sum_i (x_i - y_i)^2}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if all vectors do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.absDiff" class="PFAfcndef">
{<b>"metric.absDiff":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>y</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Similarity function (1-dimensional metric) that returns the absolute Euclidean distance between <span class="PFAp">x</span> and <span class="PFAp">y</span>.</p>
</div>
<div id="fcn:metric.gaussianSimilarity" class="PFAfcndef">
{<b>"metric.gaussianSimilarity":</b> [x, y, sigma]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>y</b></td><td>double</td></tr><tr><td><b>sigma</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Similarity function (1-dimensional metric) that returns \(\exp(-\ln(2) (x - y)^2 / \mbox{sigma}^2)\).</p>
</div>
<div id="fcn:metric.euclidean" class="PFAfcndef">
{<b>"metric.euclidean":</b> [similarity, x, y]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (any <b>A</b>, any <b>B</b>) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, <b>A</b>}</td></tr><tr><td><b>y</b></td><td>array of union of {null, <b>B</b>}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"metric.euclidean":</b> [similarity, x, y, missingWeight]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (any <b>A</b>, any <b>B</b>) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, <b>A</b>}</td></tr><tr><td><b>y</b></td><td>array of union of {null, <b>B</b>}</td></tr><tr><td><b>missingWeight</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Euclidean metric, which is the distance function for ordinary space, given by the Pythagorean formula (also known as the 2-norm).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>similarity</b></td><td>Similarity function (1-dimensional metric) that quantifies the distance between components of <span class="PFAp">x</span> and components of <span class="PFAp">y</span>.</td></tr>
<tr><td><b>x</b></td><td>First sample vector, which may have missing values.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector, which may have missing values.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
<tr><td><b>missingWeight</b></td><td>Optional missing-value weights: a vector with the same dimension as <span class="PFAp">x</span> and <span class="PFAp">y</span> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(I(x_i,y_i)\) = 0 if component \(i\) of <span class="PFAp">x</span> or <span class="PFAp">y</span> is missing, 1 otherwise, this function returns \(\sqrt{(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)}\) where \(q_i\) are components of the missing-value weights.  Without missing values, it is \(\sqrt{\sum_i \mbox{similarity}(x_i,y_i)^2}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if all vectors do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.squaredEuclidean" class="PFAfcndef">
{<b>"metric.squaredEuclidean":</b> [similarity, x, y]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"metric.squaredEuclidean":</b> [similarity, x, y, missingWeight]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><b>missingWeight</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Euclidean metric squared, which has the same ordering as the Euclidean metric, but avoids a square root calculation.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>similarity</b></td><td>Similarity function (1-dimensional metric) that quantifies the distance between components of <span class="PFAp">x</span> and components of <span class="PFAp">y</span>.</td></tr>
<tr><td><b>x</b></td><td>First sample vector, which may have missing values.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector, which may have missing values.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
<tr><td><b>missingWeight</b></td><td>Optional missing-value weights: a vector with the same dimension as <span class="PFAp">x</span> and <span class="PFAp">y</span> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(I(x_i,y_i)\) = 0 if component \(i\) of <span class="PFAp">x</span> or <span class="PFAp">y</span> is missing, 1 otherwise, this function returns \((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)\) where \(q_i\) are components of the missing-value weights.  Without missing values, it is \(\sum_i \mbox{similarity}(x_i,y_i)^2\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if all vectors do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.chebyshev" class="PFAfcndef">
{<b>"metric.chebyshev":</b> [similarity, x, y]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"metric.chebyshev":</b> [similarity, x, y, missingWeight]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><b>missingWeight</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Chebyshev metric, also known as the infinity norm or chessboard distance (since it is the number of moves required for a chess king to travel between two points).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>similarity</b></td><td>Similarity function (1-dimensional metric) that quantifies the distance between components of <span class="PFAp">x</span> and components of <span class="PFAp">y</span>.</td></tr>
<tr><td><b>x</b></td><td>First sample vector, which may have missing values.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector, which may have missing values.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
<tr><td><b>missingWeight</b></td><td>Optional missing-value weights: a vector with the same dimension as <span class="PFAp">x</span> and <span class="PFAp">y</span> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(I(x_i,y_i)\) = 0 if component \(i\) of <span class="PFAp">x</span> or <span class="PFAp">y</span> is missing, 1 otherwise, this function returns \((\max_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)\) where \(q_i\) are components of the missing-value weights.  Without missing values, it is \(\max_i \mbox{similarity}(x_i,y_i)\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if all vectors do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.taxicab" class="PFAfcndef">
{<b>"metric.taxicab":</b> [similarity, x, y]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"metric.taxicab":</b> [similarity, x, y, missingWeight]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><b>missingWeight</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Taxicab metric, also known as the 1-norm, city-block or Manhattan distance (since it is the distance when confined to a rectilinear city grid).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>similarity</b></td><td>Similarity function (1-dimensional metric) that quantifies the distance between components of <span class="PFAp">x</span> and components of <span class="PFAp">y</span>.</td></tr>
<tr><td><b>x</b></td><td>First sample vector, which may have missing values.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector, which may have missing values.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
<tr><td><b>missingWeight</b></td><td>Optional missing-value weights: a vector with the same dimension as <span class="PFAp">x</span> and <span class="PFAp">y</span> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(I(x_i,y_i)\) = 0 if component \(i\) of <span class="PFAp">x</span> or <span class="PFAp">y</span> is missing, 1 otherwise, this function returns \((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)\) where \(q_i\) are components of the missing-value weights.  Without missing values, it is \(\sum_i \mbox{similarity}(x_i,y_i)\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if all vectors do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.minkowski" class="PFAfcndef">
{<b>"metric.minkowski":</b> [similarity, x, y, p]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><b>p</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"metric.minkowski":</b> [similarity, x, y, p, missingWeight]} <br><table class="PFAwhere"><tr><td><b>similarity</b></td><td>function of (double, double) &rarr; double</td></tr><tr><td><b>x</b></td><td>array of union of {null, double}</td></tr><tr><td><b>y</b></td><td>array of union of {null, double}</td></tr><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>missingWeight</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Minkowski metric, also known as the p-norm, a generalized norm whose limits include Euclidean, Chebyshev, and Taxicab.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>similarity</b></td><td>Similarity function (1-dimensional metric) that quantifies the distance between components of <span class="PFAp">x</span> and components of <span class="PFAp">y</span>.</td></tr>
<tr><td><b>x</b></td><td>First sample vector, which may have missing values.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector, which may have missing values.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
<tr><td><b>missingWeight</b></td><td>Optional missing-value weights: a vector with the same dimension as <span class="PFAp">x</span> and <span class="PFAp">y</span> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(I(x_i,y_i)\) = 0 if component \(i\) of <span class="PFAp">x</span> or <span class="PFAp">y</span> is missing, 1 otherwise, this function returns \(((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^p)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i))^{1/p}\) where \(q_i\) are components of the missing-value weights.  Without missing values, it is \((\sum_i \mbox{similarity}(x_i,y_i)^p)^{1/p}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if all vectors do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.simpleMatching" class="PFAfcndef">
{<b>"metric.simpleMatching":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of boolean</td></tr><tr><td><b>y</b></td><td>array of boolean</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Simple metric on binary vectors.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>First sample vector.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Where \(a_{11}\) is the number of <span class="PFAp">x</span>, <span class="PFAp">y</span> coordinate pairs that are equal to <span class="PFAc">true, true</span>, \(a_{10}\) is the number of <span class="PFAc">true, false</span>, \(a_{01}\) is the number of <span class="PFAc">false, true</span>, and \(a_{00}\) is the number of <span class="PFAc">false, false</span>, this function returns \((a_{11} + a_{00})/(a_{11} + a_{10} + a_{01} + a_{00})\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if <span class="PFAp">x</span> and <span class="PFAp">y</span> do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.jaccard" class="PFAfcndef">
{<b>"metric.jaccard":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of boolean</td></tr><tr><td><b>y</b></td><td>array of boolean</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Jaccard similarity of binary vectors.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>First sample vector.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Where \(a_{11}\) is the number of <span class="PFAp">x</span>, <span class="PFAp">y</span> coordinate pairs that are equal to <span class="PFAc">true, true</span>, \(a_{10}\) is the number of <span class="PFAc">true, false</span>, \(a_{01}\) is the number of <span class="PFAc">false, true</span>, and \(a_{00}\) is the number of <span class="PFAc">false, false</span>, this function returns \(a_{11}/(a_{11} + a_{10} + a_{01})\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if <span class="PFAp">x</span> and <span class="PFAp">y</span> do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.tanimoto" class="PFAfcndef">
{<b>"metric.tanimoto":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of boolean</td></tr><tr><td><b>y</b></td><td>array of boolean</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Tanimoto similarity of binary vectors.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>First sample vector.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Where \(a_{11}\) is the number of <span class="PFAp">x</span>, <span class="PFAp">y</span> coordinate pairs that are equal to <span class="PFAc">true, true</span>, \(a_{10}\) is the number of <span class="PFAc">true, false</span>, \(a_{01}\) is the number of <span class="PFAc">false, true</span>, and \(a_{00}\) is the number of <span class="PFAc">false, false</span>, this function returns \((a_{11} + a_{00})/(a_{11} + 2*(a_{10} + a_{01}) + a_{00})\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if <span class="PFAp">x</span> and <span class="PFAp">y</span> do not have the same dimension.</li></ul></p>
</div>
<div id="fcn:metric.binarySimilarity" class="PFAfcndef">
{<b>"metric.binarySimilarity":</b> [x, y, c00, c01, c10, c11, d00, d01, d10, d11]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of boolean</td></tr><tr><td><b>y</b></td><td>array of boolean</td></tr><tr><td><b>c00</b></td><td>double</td></tr><tr><td><b>c01</b></td><td>double</td></tr><tr><td><b>c10</b></td><td>double</td></tr><tr><td><b>c11</b></td><td>double</td></tr><tr><td><b>d00</b></td><td>double</td></tr><tr><td><b>d01</b></td><td>double</td></tr><tr><td><b>d10</b></td><td>double</td></tr><tr><td><b>d11</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Genaralized similarity of binary vectors, using <span class="PFAp">c00</span>, <span class="PFAp">c01</span>, <span class="PFAp">c10</span>, <span class="PFAp">c11</span>, <span class="PFAp">d00</span>, <span class="PFAp">d01</span>, <span class="PFAp">d10</span>, and <span class="PFAp">d11</span> as parameters to reproduce all other binary similarity metrics.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>First sample vector.</td></tr>
<tr><td><b>y</b></td><td>Second sample vector.  (Must have the same dimension as <span class="PFAp">x</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Where \(a_{11}\) is the number of <span class="PFAp">x</span>, <span class="PFAp">y</span> coordinate pairs that are equal to <span class="PFAc">true, true</span>, \(a_{10}\) is the number of <span class="PFAc">true, false</span>, \(a_{01}\) is the number of <span class="PFAc">false, true</span>, and \(a_{00}\) is the number of <span class="PFAc">false, false</span>, this function returns \((c_{11}a_{11} + c_{10}a_{10} + c_{01}a_{01} + c_{00}a_{00})/(d_{11}a_{11} + d_{10}a_{10} + d_{01}a_{01} + d_{00}a_{00})\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "dimensions of vectors do not match" if <span class="PFAp">x</span> and <span class="PFAp">y</span> do not have the same dimension.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:rand">rand</h2></div>
<div id="fcn:rand.int" class="PFAfcndef">
{<b>"rand.int":</b> []} <br><table class="PFAwhere"><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"rand.int":</b> [low, high]} <br><table class="PFAwhere"><tr><td><b>low</b></td><td>int</td></tr><tr><td><b>high</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return a random integer, either on the entire entire 32-bit range or between <span class="PFAp">low</span> (inclusive) and <span class="PFAp">high</span> (exclusive).</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "high must be greater than low" error if <span class="PFAp">high</span> is less than or equal to <span class="PFAp">low</span>.</li></ul></p>
</div>
<div id="fcn:rand.long" class="PFAfcndef">
{<b>"rand.long":</b> []} <br><table class="PFAwhere"><tr><td><i>(returns)</i></td><td>long</td></tr></table>
{<b>"rand.long":</b> [low, high]} <br><table class="PFAwhere"><tr><td><b>low</b></td><td>long</td></tr><tr><td><b>high</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Return a random long integer, either on the entire 64-bit range or between <span class="PFAp">low</span> (inclusive) and <span class="PFAp">high</span> (exclusive).</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "high must be greater than low" error if <span class="PFAp">high</span> is less than or equal to <span class="PFAp">low</span>.</li></ul></p>
</div>
<div id="fcn:rand.float" class="PFAfcndef">
{<b>"rand.float":</b> [low, high]} <br><table class="PFAwhere"><tr><td><b>low</b></td><td>float</td></tr><tr><td><b>high</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
<p><b>Description:</b> Return a random float between <span class="PFAp">low</span> and <span class="PFAp">high</span>.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "high must be greater than low" error if <span class="PFAp">high</span> is less than or equal to <span class="PFAp">low</span>.</li></ul></p>
</div>
<div id="fcn:rand.double" class="PFAfcndef">
{<b>"rand.double":</b> [low, high]} <br><table class="PFAwhere"><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return a random double between <span class="PFAp">low</span> and <span class="PFAp">high</span>.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "high must be greater than low" error if <span class="PFAp">high</span> is less than or equal to <span class="PFAp">low</span>.</li></ul></p>
</div>
<div id="fcn:rand.choice" class="PFAfcndef">
{<b>"rand.choice":</b> [population]} <br><table class="PFAwhere"><tr><td><b>population</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return a random item from a bag of items.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "population must not be empty" error if <span class="PFAp">population</span> is empty.</li></ul></p>
</div>
<div id="fcn:rand.choices" class="PFAfcndef">
{<b>"rand.choices":</b> [size, population]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>population</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array of random items (with replacement) from a bag of items.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "population must not be empty" error if <span class="PFAp">population</span> is empty.</li></ul></p>
</div>
<div id="fcn:rand.sample" class="PFAfcndef">
{<b>"rand.sample":</b> [size, population]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>population</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array of random items (without replacement) from a bag of items.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "population must not be empty" error if <span class="PFAp">population</span> is empty.</li><li>Raises a "population smaller than requested subsample" error if the size of <span class="PFAp">population</span> is less than <span class="PFAp">size</span>.</li></ul></p>
</div>
<div id="fcn:rand.histogram" class="PFAfcndef">
{<b>"rand.histogram":</b> [distribution]} <br><table class="PFAwhere"><tr><td><b>distribution</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"rand.histogram":</b> [distribution]} <br><table class="PFAwhere"><tr><td><b>distribution</b></td><td>array of any record <b>A</b> with fields {<i>prob</i>: double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return a random index of <span class="PFAp">distribution</span> with probability proportional to the value of that index or a random item from <span class="PFAp">distribution</span> with probability proportional to the <span class="PFApf">prob</span> field.</p>
<p><b>Details:</b><ul><li>If the probabilities do not sum to 1.0, they will be normalized first.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "distribution must be non-empty" error if no items of <span class="PFAp">distribution</span> are non-zero.</li><li>Raises a "distribution must be finite" error if any items of <span class="PFAp">distribution</span> are infinite or <span class="PFAc">NaN</span>.</li><li>Raises a "distribution must be non-negative" error if any items of <span class="PFAp">distribution</span> are negative.</li></ul></p>
</div>
<div id="fcn:rand.string" class="PFAfcndef">
{<b>"rand.string":</b> [size]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"rand.string":</b> [size, population]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>population</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"rand.string":</b> [size, low, high]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>low</b></td><td>int</td></tr><tr><td><b>high</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return a random string with <span class="PFAp">size</span> characters from a range, if provided.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>size</b></td><td>Number of characters in the resulting string.</td></tr>
<tr><td><b>population</b></td><td>Bag of characters to choose from.  Characters repeated \(N\) times in the <span class="PFAp">population</span> have probability \(N\)/<span class="PFAp">size</span>, but order is irrelevant.</td></tr>
<tr><td><b>low</b></td><td>Minimum code-point to sample (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum code-point to sample (exclusive).</td></tr>
</table></p>
<p><b>Details:</b><ul><li>Without a range, this function samples the entire Unicode table up to and including <span class="PFAc">0xD800</span>; ASCII characters are rare.</li><li>The ASCII printable range is <span class="PFAp">low</span> = 33, <span class="PFAp">high</span> = 127.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "size must be positive" error if <span class="PFAp">size</span> is less than or equal to zero.</li><li>Raises a "high must be greater than low" error if <span class="PFAp">high</span> is less than or equal to <span class="PFAp">low</span>.</li><li>Raises an "invalid char" error if <span class="PFAp">low</span> is less than 1 or greater than <span class="PFAc">0xD800</span> or if <span class="PFAp">high</span> is less than 1 or greater than <span class="PFAc">0xD800</span>.</li></ul></p>
</div>
<div id="fcn:rand.bytes" class="PFAfcndef">
{<b>"rand.bytes":</b> [size]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
{<b>"rand.bytes":</b> [size, population]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>population</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
{<b>"rand.bytes":</b> [size, low, high]} <br><table class="PFAwhere"><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>low</b></td><td>int</td></tr><tr><td><b>high</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Return <span class="PFAp">size</span> random bytes from a range, if provided.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>size</b></td><td>Number of bytes in the result.</td></tr>
<tr><td><b>population</b></td><td>Bag of bytes to choose from.  Bytes repeated \(N\) times in the <span class="PFAp">population</span> have probability \(N\)/<span class="PFAp">size</span>, but order is irrelevant.</td></tr>
<tr><td><b>low</b></td><td>Minimum byte value to sample (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum byte value to sample (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "size must be positive" error if <span class="PFAp">size</span> is less than or equal to zero.</li><li>Raises a "high must be greater than low" error if <span class="PFAp">high</span> is less than or equal to <span class="PFAp">low</span>.</li><li>Raises an "invalid byte" error if <span class="PFAp">low</span> is less than 0 or greater than 255 or if <span class="PFAp">high</span> is less than 0 or greater than 256.</li></ul></p>
</div>
<div id="fcn:rand.uuid" class="PFAfcndef">
{<b>"rand.uuid":</b> []} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use rand.uuid4 instead<br><table class="PFAwhere"><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return a random (type 4) UUID with IETF variant (8).</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>The return value is a string with the form <span class="PFAc">xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx</span> where <span class="PFAc">x</span> are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant.</td></tr>
</table></p>
</div>
<div id="fcn:rand.uuid4" class="PFAfcndef">
{<b>"rand.uuid4":</b> []} <br><table class="PFAwhere"><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return a random (type 4) UUID with IETF variant (8).</p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>The return value is a string with the form <span class="PFAc">xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx</span> where <span class="PFAc">x</span> are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant.</td></tr>
</table></p>
</div>
<div id="fcn:rand.gaussian" class="PFAfcndef">
{<b>"rand.gaussian":</b> [mu, sigma]} <br><table class="PFAwhere"><tr><td><b>mu</b></td><td>double</td></tr><tr><td><b>sigma</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return a random number from a Gaussian (normal) distribution with mean <span class="PFAp">mu</span> and standard deviation <span class="PFAp">sigma</span>.</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:s">s</h2></div>
<div id="fcn:s.len" class="PFAfcndef">
{<b>"s.len":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the length of string <span class="PFAp">s</span>.</p>
</div>
<div id="fcn:s.substr" class="PFAfcndef">
{<b>"s.substr":</b> [s, start, end]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return the substring of <span class="PFAp">s</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive).</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li></ul></p>
</div>
<div id="fcn:s.substrto" class="PFAfcndef">
{<b>"s.substrto":</b> [s, start, end, replacement]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Replace <span class="PFAp">s</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive) with <span class="PFAp">replacement</span>.</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li></ul></p>
</div>
<div id="fcn:s.contains" class="PFAfcndef">
{<b>"s.contains":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>needle</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">haystack</span> contains <span class="PFAp">needle</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:s.count" class="PFAfcndef">
{<b>"s.count":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>needle</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Count the number of times <span class="PFAp">needle</span> appears in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:s.index" class="PFAfcndef">
{<b>"s.index":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>needle</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the lowest index where <span class="PFAp">haystack</span> contains <span class="PFAp">needle</span> or -1 if <span class="PFAp">haystack</span> does not contain <span class="PFAp">needle</span>.</p>
</div>
<div id="fcn:s.rindex" class="PFAfcndef">
{<b>"s.rindex":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>needle</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the highest index where <span class="PFAp">haystack</span> contains <span class="PFAp">needle</span> or -1 if <span class="PFAp">haystack</span> does not contain <span class="PFAp">needle</span>.</p>
</div>
<div id="fcn:s.startswith" class="PFAfcndef">
{<b>"s.startswith":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>needle</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if the first (leftmost) subseqence of <span class="PFAp">haystack</span> is equal to <span class="PFAp">needle</span>, false otherwise.</p>
</div>
<div id="fcn:s.endswith" class="PFAfcndef">
{<b>"s.endswith":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>needle</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if the last (rightmost) subseqence of <span class="PFAp">haystack</span> is equal to <span class="PFAp">needle</span>, false otherwise.</p>
</div>
<div id="fcn:s.join" class="PFAfcndef">
{<b>"s.join":</b> [array, sep]} <br><table class="PFAwhere"><tr><td><b>array</b></td><td>array of string</td></tr><tr><td><b>sep</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Combine strings from <span class="PFAp">array</span> into a single string, delimited by <span class="PFAp">sep</span>.</p>
</div>
<div id="fcn:s.split" class="PFAfcndef">
{<b>"s.split":</b> [s, sep]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>sep</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
<p><b>Description:</b> Divide a string into an array of substrings, splitting at and removing delimiters <span class="PFAp">sep</span>.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">s</span> does not contain <span class="PFAp">sep</span>, this function returns an array whose only element is <span class="PFAp">s</span>.  If <span class="PFAp">sep</span> appears at the beginning or end of <span class="PFAp">s</span>, the array begins with or ends with an empty string.  These conventions match Python's behavior. </li></ul></p>
</div>
<div id="fcn:s.hex" class="PFAfcndef">
{<b>"s.hex":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"s.hex":</b> [x, width, zeroPad]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>width</b></td><td>int</td></tr><tr><td><b>zeroPad</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Format an unsigned number as a hexidecimal string.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>The number.</td></tr>
<tr><td><b>width</b></td><td>Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.</td></tr>
<tr><td><b>zeroPad</b></td><td>If true, pad the integer with zeros to fill up to <span class="PFAp">width</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If the <span class="PFAp">precision</span> requires more space than <span class="PFAp">width</span>, the string will be wide enough to accommodate the <span class="PFAp">precision</span>.</li><li>Digits "a" (decimal 10) through "f" (decimal 15) are represented by lowercase letters.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">width</span> is negative and <span class="PFAp">zeroPad</span> is <span class="PFAc">true</span>, a "negative width cannot be used with zero-padding" error is raised.</li><li>If <span class="PFAp">x</span> is negative, a "negative number" error is raised.</li></ul></p>
</div>
<div id="fcn:s.number" class="PFAfcndef">
{<b>"s.number":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"s.number":</b> [x, width, zeroPad]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>width</b></td><td>int</td></tr><tr><td><b>zeroPad</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"s.number":</b> [x, width, precision]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>width</b></td><td>union of {int, null}</td></tr><tr><td><b>precision</b></td><td>union of {int, null}</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"s.number":</b> [x, width, precision, minNoExp, maxNoExp]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>width</b></td><td>union of {int, null}</td></tr><tr><td><b>precision</b></td><td>union of {int, null}</td></tr><tr><td><b>minNoExp</b></td><td>double</td></tr><tr><td><b>maxNoExp</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Format a number as a decimal string.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>The number.  Note that different signatures apply to integers and floating point numbers.</td></tr>
<tr><td><b>width</b></td><td>Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.</td></tr>
<tr><td><b>zeroPad</b></td><td>If true, pad the integer with zeros to fill up to <span class="PFAp">width</span>.</td></tr>
<tr><td><b>precision</b></td><td>Optional precision with which to represent the number.  If omitted, at most six digits after the decimal point will be shown, unless they are zero.</td></tr>
<tr><td><b>minNoExp</b></td><td>Minimum absolute value that is not presented in scientific notation; 0.0001 if omitted.</td></tr>
<tr><td><b>maxNoExp</b></td><td>Maxiumum absolute value that is not presented in scientific notation; 100000 if omitted.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If the <span class="PFAp">precision</span> requires more space than <span class="PFAp">width</span>, the string will be wide enough to accommodate the <span class="PFAp">precision</span>.</li><li>Floating point numbers always have a decimal point with at least one digit after the decimal, even if it is zero.</li><li>Exponents are represented by a lowercase "e" which is always followed by a sign, whether positive or negative, and an exponent of two or more digits (single-digit exponents are zero-padded).</li><li>The base of a number is preceded by a "-" if negative, but not a "+" if positive.</li><li>Special floating point values are represented in the following ways: negative zero as zero (no negative sign), not a number as "nan", positive infinity as "inf", and negative infinity as "-inf" (lowercase).  They follow the same precision and width rules as normal numbers, where applicable.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">width</span> is negative and <span class="PFAp">zeroPad</span> is <span class="PFAc">true</span>, a "negative width cannot be used with zero-padding" error is raised.</li><li>If <span class="PFAp">precision</span> is provided and is less than zero, a "negative precision" error is raised.</li></ul></p>
</div>
<div id="fcn:s.concat" class="PFAfcndef">
{<b>"s.concat":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>y</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Append <span class="PFAp">y</span> to <span class="PFAp">x</span> to form a single string.</p>
<p><b>Details:</b><ul><li>To concatenate an array of strings, use s.join with an empty string as <span class="PFAp">sep</span>.</li></ul></p>
</div>
<div id="fcn:s.repeat" class="PFAfcndef">
{<b>"s.repeat":</b> [s, n]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Create a string by concatenating <span class="PFAp">s</span> with itself <span class="PFAp">n</span> times.</p>
</div>
<div id="fcn:s.lower" class="PFAfcndef">
{<b>"s.lower":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Convert <span class="PFAp">s</span> to lower-case.</p>
</div>
<div id="fcn:s.upper" class="PFAfcndef">
{<b>"s.upper":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Convert <span class="PFAp">s</span> to upper-case.</p>
</div>
<div id="fcn:s.lstrip" class="PFAfcndef">
{<b>"s.lstrip":</b> [s, chars]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>chars</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Remove any characters found in <span class="PFAp">chars</span> from the beginning (left) of <span class="PFAp">s</span>.</p>
<p><b>Details:</b><ul><li>The order of characters in <span class="PFAp">chars</span> is irrelevant.</li></ul></p>
</div>
<div id="fcn:s.rstrip" class="PFAfcndef">
{<b>"s.rstrip":</b> [s, chars]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>chars</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Remove any characters found in <span class="PFAp">chars</span> from the end (right) of <span class="PFAp">s</span>.</p>
<p><b>Details:</b><ul><li>The order of characters in <span class="PFAp">chars</span> is irrelevant.</li></ul></p>
</div>
<div id="fcn:s.strip" class="PFAfcndef">
{<b>"s.strip":</b> [s, chars]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>chars</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Remove any characters found in <span class="PFAp">chars</span> from the beginning or end of <span class="PFAp">s</span>.</p>
<p><b>Details:</b><ul><li>The order of characters in <span class="PFAp">chars</span> is irrelevant.</li></ul></p>
</div>
<div id="fcn:s.replaceall" class="PFAfcndef">
{<b>"s.replaceall":</b> [s, original, replacement]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>original</b></td><td>string</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Replace every instance of the substring <span class="PFAp">original</span> from <span class="PFAp">s</span> with <span class="PFAp">replacement</span>.</p>
</div>
<div id="fcn:s.replacefirst" class="PFAfcndef">
{<b>"s.replacefirst":</b> [s, original, replacement]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>original</b></td><td>string</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Replace the first (leftmost) instance of the substring <span class="PFAp">original</span> from <span class="PFAp">s</span> with <span class="PFAp">replacement</span>.</p>
</div>
<div id="fcn:s.replacelast" class="PFAfcndef">
{<b>"s.replacelast":</b> [s, original, replacement]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>original</b></td><td>string</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Replace the last (rightmost) instance of the substring <span class="PFAp">original</span> from <span class="PFAp">s</span> with <span class="PFAp">replacement</span>.</p>
</div>
<div id="fcn:s.translate" class="PFAfcndef">
{<b>"s.translate":</b> [s, oldchars, newchars]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><b>oldchars</b></td><td>string</td></tr><tr><td><b>newchars</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> For each character in <span class="PFAp">s</span> that is also in <span class="PFAp">oldchars</span> with some index <span class="PFAc">i</span>, replace it with the character at index <span class="PFAc">i</span> in <span class="PFAp">newchars</span>.  Any character in <span class="PFAp">s</span> that is not in <span class="PFAp">oldchars</span> is unchanged.  Any index <span class="PFAc">i</span> that is greater than the length of <span class="PFAp">newchars</span> is replaced with nothing.</p>
<p><b>Details:</b><ul><li>This is the behavior of the the Posix command <span class="PFAc">tr</span>, where <span class="PFAp">s</span> takes the place of standard input and <span class="PFAp">oldchars</span> and <span class="PFAp">newchars</span> are the <span class="PFAc">tr</span> commandline options.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:re">re</h2></div>
<div id="fcn:re.index" class="PFAfcndef">
{<b>"re.index":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
{<b>"re.index":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Return the indices in <span class="PFAp">haystack</span> of the begining and end of the first match defined by <span class="PFAp">pattern</span>.</p>
</div>
<div id="fcn:re.contains" class="PFAfcndef">
{<b>"re.contains":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"re.contains":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return true if <span class="PFAp">pattern</span> matches anywhere within <span class="PFAp">haystack</span>, otherwise return false.</p>
</div>
<div id="fcn:re.count" class="PFAfcndef">
{<b>"re.count":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"re.count":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Count the number of times <span class="PFAp">pattern</span> matches in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.rindex" class="PFAfcndef">
{<b>"re.rindex":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
{<b>"re.rindex":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Return the location indices of the last <span class="PFAp">pattern</span> match in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.groups" class="PFAfcndef">
{<b>"re.groups":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of array of int</td></tr></table>
{<b>"re.groups":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of array of int</td></tr></table>
<p><b>Description:</b> Return the location indices of each <span class="PFAp">pattern</span> sub-match (group-match) in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.indexall" class="PFAfcndef">
{<b>"re.indexall":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of array of int</td></tr></table>
{<b>"re.indexall":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of array of int</td></tr></table>
<p><b>Description:</b> Return the location indices of every <span class="PFAp">pattern</span> match in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.findall" class="PFAfcndef">
{<b>"re.findall":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
{<b>"re.findall":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of bytes</td></tr></table>
<p><b>Description:</b> Return an array containing each string that <span class="PFAp">pattern</span> matched in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.findfirst" class="PFAfcndef">
{<b>"re.findfirst":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>union of {string, null}</td></tr></table>
{<b>"re.findfirst":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>union of {bytes, null}</td></tr></table>
<p><b>Description:</b> Return the first occurance of what <span class="PFAp">pattern</span> matched in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.findgroupsfirst" class="PFAfcndef">
{<b>"re.findgroupsfirst":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
{<b>"re.findgroupsfirst":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of bytes</td></tr></table>
<p><b>Description:</b> Return an array of strings or bytes for each <span class="PFAp">pattern</span> sub-match (group-match) at the first occurance of <span class="PFAp">pattern</span> in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.findgroupsall" class="PFAfcndef">
{<b>"re.findgroupsall":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of array of string</td></tr></table>
{<b>"re.findgroupsall":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of array of bytes</td></tr></table>
<p><b>Description:</b> Return an array of strings or bytes for each <span class="PFAp">pattern</span> sub-match (group-match) at every occurance of <span class="PFAp">pattern</span> in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.groupsall" class="PFAfcndef">
{<b>"re.groupsall":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of array of array of int</td></tr></table>
{<b>"re.groupsall":</b> [haystack, pattern]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of array of array of int</td></tr></table>
<p><b>Description:</b> Return the location indices of each <span class="PFAp">pattern</span> sub-match (group-match) for each occurance of <span class="PFAp">pattern</span> in <span class="PFAp">haystack</span>.</p>
</div>
<div id="fcn:re.replacefirst" class="PFAfcndef">
{<b>"re.replacefirst":</b> [pattern, haystack, replacement]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"re.replacefirst":</b> [pattern, haystack, replacement]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>replacement</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Replace the first <span class="PFAp">pattern</span> match in <span class="PFAp">haystack</span> with <span class="PFAp">replacement</span>.</p>
</div>
<div id="fcn:re.replacelast" class="PFAfcndef">
{<b>"re.replacelast":</b> [pattern, haystack, replacement]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"re.replacelast":</b> [pattern, haystack, replacement]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>replacement</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Replace the last <span class="PFAp">pattern</span> match in <span class="PFAp">haystack</span> with <span class="PFAp">replacement</span>.</p>
</div>
<div id="fcn:re.split" class="PFAfcndef">
{<b>"re.split":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
{<b>"re.split":</b> [pattern, haystack]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>array of bytes</td></tr></table>
<p><b>Description:</b> Break <span class="PFAp">haystack</span> into an array of strings or bytes on the separator defined by <span class="PFAp">pattern</span>.</p>
</div>
<div id="fcn:re.replaceall" class="PFAfcndef">
{<b>"re.replaceall":</b> [pattern, haystack, replacement]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>string</td></tr><tr><td><b>haystack</b></td><td>string</td></tr><tr><td><b>replacement</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
{<b>"re.replaceall":</b> [pattern, haystack, replacement]} <br><table class="PFAwhere"><tr><td><b>pattern</b></td><td>bytes</td></tr><tr><td><b>haystack</b></td><td>bytes</td></tr><tr><td><b>replacement</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Replace the all <span class="PFAp">pattern</span> matches in <span class="PFAp">haystack</span> with <span class="PFAp">replacement</span>.</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:parse">parse</h2></div>
<div id="fcn:parse.int" class="PFAfcndef">
{<b>"parse.int":</b> [str, base]} <br><table class="PFAwhere"><tr><td><b>str</b></td><td>string</td></tr><tr><td><b>base</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Parse <span class="PFAp">str</span> and return its value as an integer with base <span class="PFAp">base</span>, if possible.</p>
<p><b>Details:</b><ul><li>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises "not an integer" if the string does not conform to "<span class="PFAc">[-+]?[0-9a-z]+</span>" or the number it evaluates to is too large to represent as a 32-bit integer or uses characters as large as or larger than <span class="PFAp">base</span> ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35).</li><li>Raises "base out of range" if <span class="PFAp">base</span> is less than 2 or greater than 36.</li></ul></p>
</div>
<div id="fcn:parse.long" class="PFAfcndef">
{<b>"parse.long":</b> [str, base]} <br><table class="PFAwhere"><tr><td><b>str</b></td><td>string</td></tr><tr><td><b>base</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Parse <span class="PFAp">str</span> and return its value as a long integer with base <span class="PFAp">base</span>, if possible.</p>
<p><b>Details:</b><ul><li>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises "not a long integer" if the string does not conform to "<span class="PFAc">[-+]?[0-9a-z]+</span>" or the number it evaluates to is too large to represent as a 64-bit integer or uses characters as large as or larger than <span class="PFAp">base</span> ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35).</li><li>Raises "base out of range" if <span class="PFAp">base</span> is less than 2 or greater than 36.</li></ul></p>
</div>
<div id="fcn:parse.float" class="PFAfcndef">
{<b>"parse.float":</b> [str]} <br><table class="PFAwhere"><tr><td><b>str</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
<p><b>Description:</b> Parse <span class="PFAp">str</span> and return its value as a single-precision floating point number.</p>
<p><b>Details:</b><ul><li>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</li><li>If the string is "nan", the resulting value is not-a-number and if the string is "inf", "+inf", or "-inf", the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754).</li><li>If the number's magnitude is too large to be represented as a single-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a single-precision float, the resulting value is zero.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises "not a single-precision float" if the string does not conform to "<span class="PFAc">[-+]?[0-9]+(e[-+]?[0-9]+)?</span>".</li></ul></p>
</div>
<div id="fcn:parse.double" class="PFAfcndef">
{<b>"parse.double":</b> [str]} <br><table class="PFAwhere"><tr><td><b>str</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Parse <span class="PFAp">str</span> and return its value as a double-precision floating point number.</p>
<p><b>Details:</b><ul><li>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</li><li>If the string is "nan", the resulting value is not-a-number and if the string is "inf", "+inf", or "-inf", the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754).</li><li>If the number's magnitude is too large to be represented as a double-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a double-precision float, the resulting value is zero.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises "not a double-precision float" if the string does not conform to "<span class="PFAc">[-+]?[0-9]+(e[-+]?[0-9]+)?</span>".</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:cast">cast</h2></div>
<div id="fcn:cast.signed" class="PFAfcndef">
{<b>"cast.signed":</b> [x, bits]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>bits</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Truncate <span class="PFAp">x</span> as though its signed long two's complement representation were inserted, bit-for-bit, into a signed two's complement representation that is <span class="PFAp">bits</span> wide, removing the most significant bits.</p>
<p><b>Details:</b><ul><li>The result of this function may be negative, zero, or positive.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">bits</span> is less than 2 or greater than 64, an "unrepresentable unsigned number" error is raised.</li></ul></p>
</div>
<div id="fcn:cast.unsigned" class="PFAfcndef">
{<b>"cast.unsigned":</b> [x, bits]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><b>bits</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Truncate <span class="PFAp">x</span> as though its signed long two's complement representation were inserted, bit-for-bit, into an unsigned register that is <span class="PFAp">bits</span> wide, removing the most significant bits.</p>
<p><b>Details:</b><ul><li>The result of this function is always nonnegative.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">bits</span> is less than 1 or greater than 63, an "unrepresentable unsigned number" error is raised.</li></ul></p>
</div>
<div id="fcn:cast.int" class="PFAfcndef">
{<b>"cast.int":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"cast.int":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"cast.int":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"cast.int":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Cast <span class="PFAp">x</span> to an integer, rounding if necessary.</p>
<p><b>Runtime Errors:</b><ul><li>Results outside of -2147483648 and 2147483647 (inclusive) produce an "int overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:cast.long" class="PFAfcndef">
{<b>"cast.long":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
{<b>"cast.long":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
{<b>"cast.long":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
{<b>"cast.long":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>long</td></tr></table>
<p><b>Description:</b> Cast <span class="PFAp">x</span> to a 64-bit integer, rounding if necessary.</p>
<p><b>Runtime Errors:</b><ul><li>Results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a "long overflow" runtime error.</li></ul></p>
</div>
<div id="fcn:cast.float" class="PFAfcndef">
{<b>"cast.float":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
{<b>"cast.float":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
{<b>"cast.float":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
{<b>"cast.float":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
<p><b>Description:</b> Cast <span class="PFAp">x</span> to a single-precision floating point number, rounding if necessary.</p>
</div>
<div id="fcn:cast.double" class="PFAfcndef">
{<b>"cast.double":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"cast.double":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>long</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"cast.double":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"cast.double":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Cast <span class="PFAp">x</span> to a double-precision floating point number.</p>
</div>
<div id="fcn:cast.fanoutBoolean" class="PFAfcndef">
{<b>"cast.fanoutBoolean":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of boolean</td></tr></table>
{<b>"cast.fanoutBoolean":</b> [x, dictionary, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>dictionary</b></td><td>array of string</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of boolean</td></tr></table>
{<b>"cast.fanoutBoolean":</b> [x, minimum, maximum, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>minimum</b></td><td>int</td></tr><tr><td><b>maximum</b></td><td>int</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of boolean</td></tr></table>
<p><b>Description:</b> Fanout <span class="PFAp">x</span> to an array of booleans, all <span class="PFAc">false</span> except the matching value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Categorical datum</td></tr>
<tr><td><b>dictionary</b></td><td>Possible values of <span class="PFAp">x</span>, which is needed if <span class="PFAp">x</span> is an arbitrary string.</td></tr>
<tr><td><b>minimum</b></td><td>Inclusive minimum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>maximum</b></td><td>Excluded maximum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>outOfRange</b></td><td>If <span class="PFAc">true</span>, include an extra item in the output to represent values of <span class="PFAp">x</span> that are outside of the specified range.</td></tr>
</table></p>
</div>
<div id="fcn:cast.fanoutInt" class="PFAfcndef">
{<b>"cast.fanoutInt":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
{<b>"cast.fanoutInt":</b> [x, dictionary, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>dictionary</b></td><td>array of string</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
{<b>"cast.fanoutInt":</b> [x, minimum, maximum, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>minimum</b></td><td>int</td></tr><tr><td><b>maximum</b></td><td>int</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Fanout <span class="PFAp">x</span> to an array of booleans, all <span class="PFAc">false</span> except the matching value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Categorical datum</td></tr>
<tr><td><b>dictionary</b></td><td>Possible values of <span class="PFAp">x</span>, which is needed if <span class="PFAp">x</span> is an arbitrary string.</td></tr>
<tr><td><b>minimum</b></td><td>Inclusive minimum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>maximum</b></td><td>Excluded maximum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>outOfRange</b></td><td>If <span class="PFAc">true</span>, include an extra item in the output to represent values of <span class="PFAp">x</span> that are outside of the specified range.</td></tr>
</table></p>
</div>
<div id="fcn:cast.fanoutLong" class="PFAfcndef">
{<b>"cast.fanoutLong":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of long</td></tr></table>
{<b>"cast.fanoutLong":</b> [x, dictionary, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>dictionary</b></td><td>array of string</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of long</td></tr></table>
{<b>"cast.fanoutLong":</b> [x, minimum, maximum, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>minimum</b></td><td>int</td></tr><tr><td><b>maximum</b></td><td>int</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of long</td></tr></table>
<p><b>Description:</b> Fanout <span class="PFAp">x</span> to an array of booleans, all <span class="PFAc">false</span> except the matching value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Categorical datum</td></tr>
<tr><td><b>dictionary</b></td><td>Possible values of <span class="PFAp">x</span>, which is needed if <span class="PFAp">x</span> is an arbitrary string.</td></tr>
<tr><td><b>minimum</b></td><td>Inclusive minimum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>maximum</b></td><td>Excluded maximum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>outOfRange</b></td><td>If <span class="PFAc">true</span>, include an extra item in the output to represent values of <span class="PFAp">x</span> that are outside of the specified range.</td></tr>
</table></p>
</div>
<div id="fcn:cast.fanoutFloat" class="PFAfcndef">
{<b>"cast.fanoutFloat":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of float</td></tr></table>
{<b>"cast.fanoutFloat":</b> [x, dictionary, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>dictionary</b></td><td>array of string</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of float</td></tr></table>
{<b>"cast.fanoutFloat":</b> [x, minimum, maximum, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>minimum</b></td><td>int</td></tr><tr><td><b>maximum</b></td><td>int</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of float</td></tr></table>
<p><b>Description:</b> Fanout <span class="PFAp">x</span> to an array of booleans, all <span class="PFAc">false</span> except the matching value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Categorical datum</td></tr>
<tr><td><b>dictionary</b></td><td>Possible values of <span class="PFAp">x</span>, which is needed if <span class="PFAp">x</span> is an arbitrary string.</td></tr>
<tr><td><b>minimum</b></td><td>Inclusive minimum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>maximum</b></td><td>Excluded maximum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>outOfRange</b></td><td>If <span class="PFAc">true</span>, include an extra item in the output to represent values of <span class="PFAp">x</span> that are outside of the specified range.</td></tr>
</table></p>
</div>
<div id="fcn:cast.fanoutDouble" class="PFAfcndef">
{<b>"cast.fanoutDouble":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"cast.fanoutDouble":</b> [x, dictionary, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>dictionary</b></td><td>array of string</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"cast.fanoutDouble":</b> [x, minimum, maximum, outOfRange]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>minimum</b></td><td>int</td></tr><tr><td><b>maximum</b></td><td>int</td></tr><tr><td><b>outOfRange</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
<p><b>Description:</b> Fanout <span class="PFAp">x</span> to an array of booleans, all <span class="PFAc">false</span> except the matching value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Categorical datum</td></tr>
<tr><td><b>dictionary</b></td><td>Possible values of <span class="PFAp">x</span>, which is needed if <span class="PFAp">x</span> is an arbitrary string.</td></tr>
<tr><td><b>minimum</b></td><td>Inclusive minimum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>maximum</b></td><td>Excluded maximum value of <span class="PFAp">x</span>.</td></tr>
<tr><td><b>outOfRange</b></td><td>If <span class="PFAc">true</span>, include an extra item in the output to represent values of <span class="PFAp">x</span> that are outside of the specified range.</td></tr>
</table></p>
</div>
<div id="fcn:cast.avro" class="PFAfcndef">
{<b>"cast.avro":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode an arbitrary object as Avro bytes.</p>
<p><b>Details:</b><ul><li>May be composed with <span class="PFAf">bytes.toBase64</span> to get an efficient string representation (e.g. for map keys).</li></ul></p>
</div>
<div id="fcn:cast.json" class="PFAfcndef">
{<b>"cast.json":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Encode an arbitrary object as a JSON string.</p>
<p><b>Details:</b><ul><li>The form of this JSON string (spacing, order of keys in objects, etc.) is not guaranteed from one system to another.</li><li>Useful for building human-readable map keys.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:a">a</h2></div>
<div id="fcn:a.len" class="PFAfcndef">
{<b>"a.len":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the length of array <span class="PFAp">a</span>.</p>
</div>
<div id="fcn:a.subseq" class="PFAfcndef">
{<b>"a.subseq":</b> [a, start, end]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the subsequence of <span class="PFAp">a</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive).</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li></ul></p>
</div>
<div id="fcn:a.head" class="PFAfcndef">
{<b>"a.head":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the first item of the array.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.tail" class="PFAfcndef">
{<b>"a.tail":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return all but the first item of the array.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.last" class="PFAfcndef">
{<b>"a.last":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the last item of the array.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.init" class="PFAfcndef">
{<b>"a.init":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return all but the last item of the array.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.subseqto" class="PFAfcndef">
{<b>"a.subseqto":</b> [a, start, end, replacement]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><b>replacement</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new array by replacing <span class="PFAp">a</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive) with <span class="PFAp">replacement</span>.</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li></ul></p>
</div>
<div id="fcn:a.contains" class="PFAfcndef">
{<b>"a.contains":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"a.contains":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"a.contains":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">haystack</span> contains <span class="PFAp">needle</span> or the <span class="PFAp">needle</span> function evaluates to <span class="PFAc">true</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:a.count" class="PFAfcndef">
{<b>"a.count":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"a.count":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"a.count":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Count the number of times <span class="PFAp">needle</span> appears in <span class="PFAp">haystack</span> or the number of times the <span class="PFAp">needle</span> function evaluates to <span class="PFAc">true</span>.</p>
</div>
<div id="fcn:a.index" class="PFAfcndef">
{<b>"a.index":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"a.index":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"a.index":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the lowest index where <span class="PFAp">haystack</span> contains <span class="PFAp">needle</span> or the <span class="PFAp">needle</span> function evaluates to <span class="PFAc">true</span>, \(-1\) if there is no such element.</p>
</div>
<div id="fcn:a.rindex" class="PFAfcndef">
{<b>"a.rindex":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"a.rindex":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"a.rindex":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the highest index where <span class="PFAp">haystack</span> contains <span class="PFAp">needle</span> or the <span class="PFAp">needle</span> function evaluates to <span class="PFAc">true</span>, \(-1\) if there is no such element.</p>
</div>
<div id="fcn:a.startswith" class="PFAfcndef">
{<b>"a.startswith":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"a.startswith":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if the first (leftmost) subseqence of <span class="PFAp">haystack</span> is equal to <span class="PFAp">needle</span>, false otherwise.</p>
</div>
<div id="fcn:a.endswith" class="PFAfcndef">
{<b>"a.endswith":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"a.endswith":</b> [haystack, needle]} <br><table class="PFAwhere"><tr><td><b>haystack</b></td><td>array of any <b>A</b></td></tr><tr><td><b>needle</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if the last (rightmost) subseqence of <span class="PFAp">haystack</span> is equal to <span class="PFAp">needle</span>, false otherwise.</p>
</div>
<div id="fcn:a.concat" class="PFAfcndef">
{<b>"a.concat":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Concatenate <span class="PFAp">a</span> and <span class="PFAp">b</span> to make a new array of the same type.</p>
<p><b>Details:</b><ul><li>The length of the returned array is the sum of the lengths of <span class="PFAp">a</span> and <span class="PFAp">b</span>.</li></ul></p>
</div>
<div id="fcn:a.append" class="PFAfcndef">
{<b>"a.append":</b> [a, item]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>item</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new array by adding <span class="PFAp">item</span> at the end of <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li><li>The length of the returned array is one more than <span class="PFAp">a</span>.</li></ul></p>
</div>
<div id="fcn:a.cycle" class="PFAfcndef">
{<b>"a.cycle":</b> [a, item, maxLength]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>item</b></td><td><b>A</b></td></tr><tr><td><b>maxLength</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new array by adding <span class="PFAp">item</span> at the end of <span class="PFAp">a</span>, but keep the length less than or equal to <span class="PFAp">maxLength</span> by removing items from the beginning.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">maxLength</span> is less than 0, this function raises a "maxLength out of range" error.</li></ul></p>
</div>
<div id="fcn:a.insert" class="PFAfcndef">
{<b>"a.insert":</b> [a, index, item]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>index</b></td><td>int</td></tr><tr><td><b>item</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new array by inserting <span class="PFAp">item</span> at <span class="PFAp">index</span> of <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), following Python's index behavior.</li><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li><li>The length of the returned array is one more than <span class="PFAp">a</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">index</span> is beyond the range of <span class="PFAp">a</span>, an "array out of range" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.replace" class="PFAfcndef">
{<b>"a.replace":</b> [a, index, item]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>index</b></td><td>int</td></tr><tr><td><b>item</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new array by replacing <span class="PFAp">index</span> of <span class="PFAp">a</span> with <span class="PFAp">item</span>.</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), following Python's index behavior.</li><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li><li>The length of the returned array is equal to that of <span class="PFAp">a</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">index</span> is beyond the range of <span class="PFAp">a</span>, an "array out of range" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.remove" class="PFAfcndef">
{<b>"a.remove":</b> [a, start, end]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
{<b>"a.remove":</b> [a, index]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>index</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new array by removing elements from <span class="PFAp">a</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive) or just a single <span class="PFAp">index</span>.</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li><li>The length of the returned array is one less than <span class="PFAp">a</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">index</span> is beyond the range of <span class="PFAp">a</span>, an "array out of range" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.rotate" class="PFAfcndef">
{<b>"a.rotate":</b> [a, steps]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>steps</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array formed by rotating <span class="PFAp">a</span> left <span class="PFAp">steps</span> spaces.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">steps</span> is less than zero, a "steps out of range" error is raised.</li></ul></p>
</div>
<div id="fcn:a.sort" class="PFAfcndef">
{<b>"a.sort":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array with the same elements as <span class="PFAp">a</span> but in ascending order (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li></ul></p>
</div>
<div id="fcn:a.sortLT" class="PFAfcndef">
{<b>"a.sortLT":</b> [a, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array with the same elements as <span class="PFAp">a</span> but in ascending order as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function.</li></ul></p>
</div>
<div id="fcn:a.shuffle" class="PFAfcndef">
{<b>"a.shuffle":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array with the same elements as <span class="PFAp">a</span> but in a random order.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">a</span> is not changed in-place; this is a side-effect-free function (except for updating the random number generator).</li></ul></p>
</div>
<div id="fcn:a.reverse" class="PFAfcndef">
{<b>"a.reverse":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the elements of <span class="PFAp">a</span> in reversed order.</p>
</div>
<div id="fcn:a.max" class="PFAfcndef">
{<b>"a.max":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the maximum value in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.min" class="PFAfcndef">
{<b>"a.min":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the minimum value in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.maxLT" class="PFAfcndef">
{<b>"a.maxLT":</b> [a, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the maximum value in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.minLT" class="PFAfcndef">
{<b>"a.minLT":</b> [a, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the minimum value in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.maxN" class="PFAfcndef">
{<b>"a.maxN":</b> [a, n]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the <span class="PFAp">n</span> highest values in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.minN" class="PFAfcndef">
{<b>"a.minN":</b> [a, n]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the <span class="PFAp">n</span> lowest values in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.maxNLT" class="PFAfcndef">
{<b>"a.maxNLT":</b> [a, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the <span class="PFAp">n</span> highest values in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.minNLT" class="PFAfcndef">
{<b>"a.minNLT":</b> [a, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the <span class="PFAp">n</span> lowest values in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argmax" class="PFAfcndef">
{<b>"a.argmax":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the index of the maximum value in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If the maximum is not unique, this function returns the index of the first maximal value.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argmin" class="PFAfcndef">
{<b>"a.argmin":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the index of the minimum value in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If the minimum is not unique, this function returns the index of the first minimal value.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argmaxLT" class="PFAfcndef">
{<b>"a.argmaxLT":</b> [a, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the index of the maximum value in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If the maximum is not unique, this function returns the index of the first maximal value.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argminLT" class="PFAfcndef">
{<b>"a.argminLT":</b> [a, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the index of the minimum value in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If the minimum is not unique, this function returns the index of the first minimal value.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argmaxN" class="PFAfcndef">
{<b>"a.argmaxN":</b> [a, n]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Return the indexes of the <span class="PFAp">n</span> highest values in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If any values are not unique, their indexes will be returned in ascending order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argminN" class="PFAfcndef">
{<b>"a.argminN":</b> [a, n]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Return the indexes of the <span class="PFAp">n</span> lowest values in <span class="PFAp">a</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If any values are not unique, their indexes will be returned in ascending order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argmaxNLT" class="PFAfcndef">
{<b>"a.argmaxNLT":</b> [a, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Return the indexes of the <span class="PFAp">n</span> highest values in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If any values are not unique, their indexes will be returned in ascending order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.argminNLT" class="PFAfcndef">
{<b>"a.argminNLT":</b> [a, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of int</td></tr></table>
<p><b>Description:</b> Return the indexes of the <span class="PFAp">n</span> lowest values in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If any values are not unique, their indexes will be returned in ascending order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.sum" class="PFAfcndef">
{<b>"a.sum":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b> of {int, long, float, double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the sum of numbers in <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Returns zero if the array is empty.</li></ul></p>
</div>
<div id="fcn:a.product" class="PFAfcndef">
{<b>"a.product":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b> of {int, long, float, double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the product of numbers in <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Returns one if the array is empty.</li></ul></p>
</div>
<div id="fcn:a.lnsum" class="PFAfcndef">
{<b>"a.lnsum":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the sum of the natural logarithm of numbers in <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Returns zero if the array is empty and <span class="PFAc">NaN</span> if any value in the array is zero or negative.</li></ul></p>
</div>
<div id="fcn:a.mean" class="PFAfcndef">
{<b>"a.mean":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the arithmetic mean of numbers in <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Returns <span class="PFAc">NaN</span> if the array is empty.</li></ul></p>
</div>
<div id="fcn:a.geomean" class="PFAfcndef">
{<b>"a.geomean":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the geometric mean of numbers in <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>Returns <span class="PFAc">NaN</span> if the array is empty.</li></ul></p>
</div>
<div id="fcn:a.median" class="PFAfcndef">
{<b>"a.median":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the value that is in the center of a sorted version of <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">a</span> has an odd number of elements, the median is the exact center of the sorted array.  If <span class="PFAp">a</span> has an even number of elements and is a <span class="PFAc">float</span> or <span class="PFAc">double</span>, the median is the average of the two elements closest to the center of the sorted array.  For any other type, the median is the left (first) of the two elements closest to the center of the sorted array.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.ntile" class="PFAfcndef">
{<b>"a.ntile":</b> [a, p]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>p</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the value that is at the "n-tile" of <span class="PFAp">a</span> (like a percentile).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>a</b></td><td>Array of objects to be take the percentile of.</td></tr>
<tr><td><b>p</b></td><td>A double between 0 and 1.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If <span class="PFAp">a</span> has an even number of elements and is a <span class="PFAc">float</span> or <span class="PFAc">double</span>, this function will take the average of the two elements closest to the center of the sorted array.  For any other type, it returns the left (first) of the two elements closest to the center of the sorted array.  If <span class="PFAp">p</span> is exactly one (or greater), the max of the array is returned.  If <span class="PFAp">p</span> is zero (or less), the min of the array is returned.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.mode" class="PFAfcndef">
{<b>"a.mode":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Return the mode (most common) value of <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>If several different values are equally common, the median of these is returned.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">a</span> is empty, an "empty array" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.logsumexp" class="PFAfcndef">
{<b>"a.logsumexp":</b> [datum]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute \(z = \\sum_{n = 1}^{N} e^{x_n}\) in a numerically stable way.</p>
<p><b>Details:</b><ul><li>Returns <span class="PFAc">NaN</span> if the array is empty.</li></ul></p>
</div>
<div id="fcn:a.distinct" class="PFAfcndef">
{<b>"a.distinct":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array with the same contents as <span class="PFAp">a</span> but with duplicates removed.</p>
</div>
<div id="fcn:a.seteq" class="PFAfcndef">
{<b>"a.seteq":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">a</span> and <span class="PFAp">b</span> are equivalent, ignoring order and duplicates, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:a.union" class="PFAfcndef">
{<b>"a.union":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array that represents the union of <span class="PFAp">a</span> and <span class="PFAp">b</span>, treated as sets (ignoring order and duplicates).</p>
</div>
<div id="fcn:a.intersection" class="PFAfcndef">
{<b>"a.intersection":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array that represents the intersection of <span class="PFAp">a</span> and <span class="PFAp">b</span>, treated as sets (ignoring order and duplicates).</p>
</div>
<div id="fcn:a.diff" class="PFAfcndef">
{<b>"a.diff":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array that represents the difference of <span class="PFAp">a</span> and <span class="PFAp">b</span>, treated as sets (ignoring order and duplicates).</p>
</div>
<div id="fcn:a.symdiff" class="PFAfcndef">
{<b>"a.symdiff":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array that represents the symmetric difference of <span class="PFAp">a</span> and <span class="PFAp">b</span>, treated as sets (ignoring order and duplicates).</p>
<p><b>Details:</b><ul><li>The symmetric difference is (<span class="PFAp">a</span> diff <span class="PFAp">b</span>) union (<span class="PFAp">b</span> diff <span class="PFAp">a</span>).</li></ul></p>
</div>
<div id="fcn:a.subset" class="PFAfcndef">
{<b>"a.subset":</b> [little, big]} <br><table class="PFAwhere"><tr><td><b>little</b></td><td>array of any <b>A</b></td></tr><tr><td><b>big</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">little</span> is a subset of <span class="PFAp">big</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:a.disjoint" class="PFAfcndef">
{<b>"a.disjoint":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">a</span> and <span class="PFAp">b</span> are disjoint, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:a.map" class="PFAfcndef">
{<b>"a.map":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and return an array of the results.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.mapWithIndex" class="PFAfcndef">
{<b>"a.mapWithIndex":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>) &rarr; any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to index, element pairs from <span class="PFAp">a</span> and return an array of the results.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.filter" class="PFAfcndef">
{<b>"a.filter":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and return an array of the elements for which <span class="PFAp">fcn</span> returns <span class="PFAc">true</span>.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.filterWithIndex" class="PFAfcndef">
{<b>"a.filterWithIndex":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each index, element pair of <span class="PFAp">a</span> and return an array of the elements for which <span class="PFAp">fcn</span> returns <span class="PFAc">true</span>.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.filterMap" class="PFAfcndef">
{<b>"a.filterMap":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; union of {any <b>B</b>, null}</td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and return an array of the results that are not <span class="PFAc">null</span>.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.filterMapWithIndex" class="PFAfcndef">
{<b>"a.filterMapWithIndex":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>) &rarr; union of {any <b>B</b>, null}</td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each index, element pair of <span class="PFAp">a</span> and return an array of the results that are not <span class="PFAc">null</span>.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.flatMap" class="PFAfcndef">
{<b>"a.flatMap":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; array of any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and flatten the resulting arrays into a single array.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.flatMapWithIndex" class="PFAfcndef">
{<b>"a.flatMapWithIndex":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>) &rarr; array of any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each index, element pair of <span class="PFAp">a</span> and flatten the resulting arrays into a single array.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it will be called exactly once for each element.</li></ul></p>
</div>
<div id="fcn:a.zipmap" class="PFAfcndef">
{<b>"a.zipmap":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>Z</b></td></tr></table>
{<b>"a.zipmap":</b> [a, b, c, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>c</b></td><td>array of any <b>C</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>, <b>C</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>Z</b></td></tr></table>
{<b>"a.zipmap":</b> [a, b, c, d, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>c</b></td><td>array of any <b>C</b></td></tr><tr><td><b>d</b></td><td>array of any <b>D</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>Z</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to the elements of <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> in lock-step and return a result for row.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned arrays" error if <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> do not all have the same length.</li></ul></p>
</div>
<div id="fcn:a.zipmapWithIndex" class="PFAfcndef">
{<b>"a.zipmapWithIndex":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>, <b>B</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>Z</b></td></tr></table>
{<b>"a.zipmapWithIndex":</b> [a, b, c, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>c</b></td><td>array of any <b>C</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>, <b>B</b>, <b>C</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>Z</b></td></tr></table>
{<b>"a.zipmapWithIndex":</b> [a, b, c, d, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>c</b></td><td>array of any <b>C</b></td></tr><tr><td><b>d</b></td><td>array of any <b>D</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>Z</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to the indexes and elements of <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> in lock-step and return a result for row.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned arrays" error if <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> do not all have the same length.</li></ul></p>
</div>
<div id="fcn:a.reduce" class="PFAfcndef">
{<b>"a.reduce":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and accumulate a tally.</p>
<p><b>Details:</b><ul><li>The first parameter of <span class="PFAp">fcn</span> is the running tally and the second parameter is an element from <span class="PFAp">a</span>.</li><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, <span class="PFAp">fcn</span> should be associative.  It need not be commutative.</li></ul></p>
</div>
<div id="fcn:a.reduceRight" class="PFAfcndef">
{<b>"a.reduceRight":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; <b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and accumulate a tally.</p>
<p><b>Details:</b><ul><li>The first parameter of <span class="PFAp">fcn</span> is an element from <span class="PFAp">a</span> and the second parameter is the running tally.</li><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, <span class="PFAp">fcn</span> should be associative.  It need not be commutative.</li></ul></p>
</div>
<div id="fcn:a.fold" class="PFAfcndef">
{<b>"a.fold":</b> [a, zero, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>zero</b></td><td>any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>B</b>, <b>A</b>) &rarr; <b>B</b></td></tr><tr><td><i>(returns)</i></td><td><b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and accumulate a tally, starting with <span class="PFAp">zero</span>.</p>
<p><b>Details:</b><ul><li>The first parameter of <span class="PFAp">fcn</span> is the running tally and the second parameter is an element from <span class="PFAp">a</span>.</li><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, <span class="PFAp">fcn</span> should be associative with <span class="PFAp">zero</span> as its identity; that is, <span class="PFAc">fcn(zero, zero) = zero</span>.  It need not be commutative.</li></ul></p>
</div>
<div id="fcn:a.foldRight" class="PFAfcndef">
{<b>"a.foldRight":</b> [a, zero, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>zero</b></td><td>any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>B</b>, <b>A</b>) &rarr; <b>B</b></td></tr><tr><td><i>(returns)</i></td><td><b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each element of <span class="PFAp">a</span> and accumulate a tally, starting with <span class="PFAp">zero</span>.</p>
<p><b>Details:</b><ul><li>The first parameter of <span class="PFAp">fcn</span> is an element from <span class="PFAp">a</span> and the second parameter is the running tally.</li><li>The order in which <span class="PFAp">fcn</span> is called on elements of <span class="PFAp">a</span> is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, <span class="PFAp">fcn</span> should be associative with <span class="PFAp">zero</span> as its identity; that is, <span class="PFAc">fcn(zero, zero) = zero</span>.  It need not be commutative.</li></ul></p>
</div>
<div id="fcn:a.takeWhile" class="PFAfcndef">
{<b>"a.takeWhile":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to elements of <span class="PFAp">a</span> and create an array of the longest prefix that returns <span class="PFAc">true</span>, stopping with the first <span class="PFAc">false</span>.</p>
<p><b>Details:</b><ul><li>Beyond the prefix, the number of <span class="PFAp">fcn</span> calls is not guaranteed.</li></ul></p>
</div>
<div id="fcn:a.dropWhile" class="PFAfcndef">
{<b>"a.dropWhile":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to elements of <span class="PFAp">a</span> and create an array of all elements after the longest prefix that returns <span class="PFAc">true</span>.</p>
<p><b>Details:</b><ul><li>Beyond the prefix, the number of <span class="PFAp">fcn</span> calls is not guaranteed.</li></ul></p>
</div>
<div id="fcn:a.any" class="PFAfcndef">
{<b>"a.any":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">fcn</span> is <span class="PFAc">true</span> for any element in <span class="PFAp">a</span> (logical or).</p>
<p><b>Details:</b><ul><li>The number of <span class="PFAp">fcn</span> calls is not guaranteed.</li></ul></p>
</div>
<div id="fcn:a.all" class="PFAfcndef">
{<b>"a.all":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">fcn</span> is <span class="PFAc">true</span> for all elements in <span class="PFAp">a</span> (logical and).</p>
<p><b>Details:</b><ul><li>The number of <span class="PFAp">fcn</span> calls is not guaranteed.</li></ul></p>
</div>
<div id="fcn:a.corresponds" class="PFAfcndef">
{<b>"a.corresponds":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">fcn</span> is <span class="PFAc">true</span> when applied to all pairs of elements, one from <span class="PFAp">a</span> and the other from <span class="PFAp">b</span> (logical relation).</p>
<p><b>Details:</b><ul><li>The number of <span class="PFAp">fcn</span> calls is not guaranteed.</li><li>If the lengths of <span class="PFAp">a</span> and <span class="PFAp">b</span> are not equal, this function returns <span class="PFAc">false</span>.</li></ul></p>
</div>
<div id="fcn:a.correspondsWithIndex" class="PFAfcndef">
{<b>"a.correspondsWithIndex":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>b</b></td><td>array of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (int, <b>A</b>, <b>B</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">fcn</span> is <span class="PFAc">true</span> when applied to all triples of index, element from <span class="PFAp">a</span>, element from <span class="PFAp">b</span> (logical relation).</p>
<p><b>Details:</b><ul><li>The number of <span class="PFAp">fcn</span> calls is not guaranteed.</li><li>If the lengths of <span class="PFAp">a</span> and <span class="PFAp">b</span> are not equal, this function returns <span class="PFAc">false</span>.</li></ul></p>
</div>
<div id="fcn:a.slidingWindow" class="PFAfcndef">
{<b>"a.slidingWindow":</b> [a, size, step, allowIncomplete]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>step</b></td><td>int</td></tr><tr><td><b>allowIncomplete</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>array of array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return an array of subsequences of <span class="PFAp">a</span> with length <span class="PFAp">size</span> that slide through <span class="PFAp">a</span> in steps of length <span class="PFAp">step</span> from left to right.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">allowIncomplete</span> is <span class="PFAc">true</span>, the last window may be smaller than <span class="PFAp">size</span>.  If <span class="PFAc">false</span>, the last window may be skipped.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">size</span> is non-positive, a "size &lt; 1" runtime error is raised.</li><li>If <span class="PFAp">step</span> is non-positive, a "step &lt; 1" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.combinations" class="PFAfcndef">
{<b>"a.combinations":</b> [a, size]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the unique combinations of <span class="PFAp">a</span> with length <span class="PFAp">size</span>.</p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">size</span> is non-positive, a "size &lt; 1" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:a.permutations" class="PFAfcndef">
{<b>"a.permutations":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the permutations of <span class="PFAp">a</span>.</p>
<p><b>Details:</b><ul><li>This function scales rapidly with the length of the array.  For reasonably large arrays, it will result in timeout exceptions.</li></ul></p>
</div>
<div id="fcn:a.flatten" class="PFAfcndef">
{<b>"a.flatten":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Concatenate the arrays in <span class="PFAp">a</span>.</p>
</div>
<div id="fcn:a.groupby" class="PFAfcndef">
{<b>"a.groupby":</b> [a, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; string</td></tr><tr><td><i>(returns)</i></td><td>map of array of <b>A</b></td></tr></table>
<p><b>Description:</b> Groups elements of <span class="PFAp">a</span> by the string that <span class="PFAp">fcn</span> maps them to.</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:map">map</h2></div>
<div id="fcn:map.len" class="PFAfcndef">
{<b>"map.len":</b> [m]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the length of a map.</p>
</div>
<div id="fcn:map.keys" class="PFAfcndef">
{<b>"map.keys":</b> [m]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
<p><b>Description:</b> Return the keys of a map (in no particular order).</p>
</div>
<div id="fcn:map.values" class="PFAfcndef">
{<b>"map.values":</b> [m]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the values of a map (in no particular order).</p>
</div>
<div id="fcn:map.containsKey" class="PFAfcndef">
{<b>"map.containsKey":</b> [m, key]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>key</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"map.containsKey":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (string) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if the keys of <span class="PFAp">m</span> contains <span class="PFAp">key</span> or <span class="PFAp">fcn</span> evaluates to <span class="PFAc">true</span> for some key of <span class="PFAp">m</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:map.containsValue" class="PFAfcndef">
{<b>"map.containsValue":</b> [m, value]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>value</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"map.containsValue":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if the values of <span class="PFAp">m</span> contains <span class="PFAp">value</span> or <span class="PFAp">fcn</span> evaluates to <span class="PFAc">true</span> for some key of <span class="PFAp">m</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:map.add" class="PFAfcndef">
{<b>"map.add":</b> [m, key, value]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>key</b></td><td>string</td></tr><tr><td><b>value</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
{<b>"map.add":</b> [m, item]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>item</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new map by adding the <span class="PFAp">key</span> <span class="PFAp">value</span> pair to <span class="PFAp">m</span> or a new set by adding the <span class="PFAp">item</span> to set <span class="PFAp">m</span>, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">m</span> is not changed in-place; this is a side-effect-free function.</li><li>If <span class="PFAp">key</span> is in <span class="PFAp">m</span>, its value will be replaced.</li><li>The serialization format for keys of sets is base64-encoded Avro.</li></ul></p>
</div>
<div id="fcn:map.remove" class="PFAfcndef">
{<b>"map.remove":</b> [m, key]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>key</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new map by removing <span class="PFAp">key</span> from <span class="PFAp">m</span>.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">m</span> is not changed in-place; this is a side-effect-free function.</li><li>If <span class="PFAp">key</span> is not in <span class="PFAp">m</span>, the return value is simply <span class="PFAp">m</span>.</li></ul></p>
</div>
<div id="fcn:map.only" class="PFAfcndef">
{<b>"map.only":</b> [m, keys]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>keys</b></td><td>array of string</td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new map, keeping only <span class="PFAp">keys</span> from <span class="PFAp">m</span>.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">m</span> is not changed in-place; this is a side-effect-free function.</li><li>If some <span class="PFAp">keys</span> are not in <span class="PFAp">m</span>, they are ignored and do not appear in the return value.</li></ul></p>
</div>
<div id="fcn:map.except" class="PFAfcndef">
{<b>"map.except":</b> [m, keys]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>keys</b></td><td>array of string</td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new map, keeping all but <span class="PFAp">keys</span> from <span class="PFAp">m</span>.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">m</span> is not changed in-place; this is a side-effect-free function.</li><li>If some <span class="PFAp">keys</span> are not in <span class="PFAp">m</span>, they are ignored and do not appear in the return value.</li></ul></p>
</div>
<div id="fcn:map.update" class="PFAfcndef">
{<b>"map.update":</b> [base, overlay]} <br><table class="PFAwhere"><tr><td><b>base</b></td><td>map of any <b>A</b></td></tr><tr><td><b>overlay</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return a new map with key-value pairs from <span class="PFAp">overlay</span> in place of or in addition to key-value pairs from <span class="PFAp">base</span>.</p>
<p><b>Details:</b><ul><li>Note: <span class="PFAp">m</span> is not changed in-place; this is a side-effect-free function.</li><li>Keys of <span class="PFAp">overlay</span> that are not in <span class="PFAp">base</span> are added to those in <span class="PFAp">base</span> and keys of <span class="PFAp">overlay</span> that are in <span class="PFAp">base</span> supersede those in <span class="PFAp">base</span>.</li></ul></p>
</div>
<div id="fcn:map.split" class="PFAfcndef">
{<b>"map.split":</b> [m]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of map of <b>A</b></td></tr></table>
<p><b>Description:</b> Split the map into an array of maps, each containing only one key-value pair.</p>
</div>
<div id="fcn:map.join" class="PFAfcndef">
{<b>"map.join":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Join an array of maps into one map, overlaying from left to right.</p>
</div>
<div id="fcn:map.argmax" class="PFAfcndef">
{<b>"map.argmax":</b> [m]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return the key of the highest value in <span class="PFAp">m</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argmin" class="PFAfcndef">
{<b>"map.argmin":</b> [m]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return the key of the lowest value in <span class="PFAp">m</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argmaxLT" class="PFAfcndef">
{<b>"map.argmaxLT":</b> [m, lessThan]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return the key of the highest value in <span class="PFAp">m</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argminLT" class="PFAfcndef">
{<b>"map.argminLT":</b> [m, lessThan]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return the key of the lowest value in <span class="PFAp">m</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argmaxN" class="PFAfcndef">
{<b>"map.argmaxN":</b> [m, n]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
<p><b>Description:</b> Return the keys of the <span class="PFAp">n</span> highest values in <span class="PFAp">m</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argminN" class="PFAfcndef">
{<b>"map.argminN":</b> [m, n]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
<p><b>Description:</b> Return the keys of the <span class="PFAp">n</span> lowest values in <span class="PFAp">m</span> (as defined by Avro's sort order).</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argmaxNLT" class="PFAfcndef">
{<b>"map.argmaxNLT":</b> [m, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
<p><b>Description:</b> Return the keys of the <span class="PFAp">n</span> highest values in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.argminNLT" class="PFAfcndef">
{<b>"map.argminNLT":</b> [m, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of string</td></tr></table>
<p><b>Description:</b> Return the keys of the <span class="PFAp">n</span> highest values in <span class="PFAp">a</span> as defined by the <span class="PFAp">lessThan</span> function.</p>
<p><b>Details:</b><ul><li>If any values are not unique, their keys will be returned in lexicographic order.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">m</span> is empty, an "empty map" runtime error is raised.</li><li>If <span class="PFAp">n</span> is negative, an "n &lt; 0" runtime error is raised.</li></ul></p>
</div>
<div id="fcn:map.toset" class="PFAfcndef">
{<b>"map.toset":</b> [a]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>array of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Convert an array of objects into a set of objects, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li></ul></p>
</div>
<div id="fcn:map.fromset" class="PFAfcndef">
{<b>"map.fromset":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>map of any <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Convert a set of objects into an array of objects, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only values, not keys.</li></ul></p>
</div>
<div id="fcn:map.in" class="PFAfcndef">
{<b>"map.in":</b> [s, x]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>map of any <b>A</b></td></tr><tr><td><b>x</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is contained in set <span class="PFAp">s</span>, <span class="PFAc">false</span> otherwise, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.union" class="PFAfcndef">
{<b>"map.union":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the union of sets <span class="PFAp">a</span> and <span class="PFAp">b</span>, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.intersection" class="PFAfcndef">
{<b>"map.intersection":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the intersection of sets <span class="PFAp">a</span> and <span class="PFAp">b</span>, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.diff" class="PFAfcndef">
{<b>"map.diff":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the difference of sets <span class="PFAp">a</span> and <span class="PFAp">b</span>, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.symdiff" class="PFAfcndef">
{<b>"map.symdiff":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Return the difference of sets <span class="PFAp">a</span> and <span class="PFAp">b</span>, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.subset" class="PFAfcndef">
{<b>"map.subset":</b> [little, big]} <br><table class="PFAwhere"><tr><td><b>little</b></td><td>map of any <b>A</b></td></tr><tr><td><b>big</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if set <span class="PFAp">little</span> is a subset of set <span class="PFAp">big</span>, <span class="PFAc">false</span> otherwise, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.disjoint" class="PFAfcndef">
{<b>"map.disjoint":</b> [a, b]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if set <span class="PFAp">a</span> and set <span class="PFAp">b</span> are disjoint, <span class="PFAc">false</span> otherwise, where a set is represented as a map from serialized objects to objects.</p>
<p><b>Details:</b><ul><li>The serialization format is base64-encoded Avro.</li><li>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</li></ul></p>
</div>
<div id="fcn:map.map" class="PFAfcndef">
{<b>"map.map":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each value of <span class="PFAp">m</span> and return a map of transformed values (keys are unchanged).</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li><li>To transform both keys and values, consider applying <span class="PFAf">map.split</span>, <span class="PFAf">a.map</span>, then <span class="PFAf">map.join</span>.</li></ul></p>
</div>
<div id="fcn:map.mapWithKey" class="PFAfcndef">
{<b>"map.mapWithKey":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>) &rarr; any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each key, value pair of <span class="PFAp">m</span> and return a map of transformed values (keys are unchanged).</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li><li>To transform both keys and values, consider applying <span class="PFAf">map.split</span>, <span class="PFAf">a.map</span>, then <span class="PFAf">map.join</span>.</li></ul></p>
</div>
<div id="fcn:map.filter" class="PFAfcndef">
{<b>"map.filter":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each value of <span class="PFAp">m</span> and return a map of the values for which <span class="PFAp">fcn</span> returns <span class="PFAc">true</span> (keys are unchanged).</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li></ul></p>
</div>
<div id="fcn:map.filterWithKey" class="PFAfcndef">
{<b>"map.filterWithKey":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>map of <b>A</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each value of <span class="PFAp">m</span> and return a map of the values for which <span class="PFAp">fcn</span> returns <span class="PFAc">true</span> (keys are unchanged).</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li></ul></p>
</div>
<div id="fcn:map.filterMap" class="PFAfcndef">
{<b>"map.filterMap":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; union of {any <b>B</b>, null}</td></tr><tr><td><i>(returns)</i></td><td>map of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each value of <span class="PFAp">m</span> and return a map of the results that are not <span class="PFAc">null</span>.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li></ul></p>
</div>
<div id="fcn:map.filterMapWithKey" class="PFAfcndef">
{<b>"map.filterMapWithKey":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>) &rarr; union of {any <b>B</b>, null}</td></tr><tr><td><i>(returns)</i></td><td>map of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each key-value pair of <span class="PFAp">m</span> and return a map of the results that are not <span class="PFAc">null</span>.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li></ul></p>
</div>
<div id="fcn:map.flatMap" class="PFAfcndef">
{<b>"map.flatMap":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>) &rarr; map of any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each value of <span class="PFAp">m</span> and return a map of overlaid results.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li></ul></p>
</div>
<div id="fcn:map.flatMapWithKey" class="PFAfcndef">
{<b>"map.flatMapWithKey":</b> [m, fcn]} <br><table class="PFAwhere"><tr><td><b>m</b></td><td>map of any <b>A</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>) &rarr; map of any <b>B</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>B</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to each key-value pair of <span class="PFAp">m</span> and return a map of overlaid results.</p>
<p><b>Details:</b><ul><li>The order in which <span class="PFAp">fcn</span> is called on items in <span class="PFAp">m</span> is not guaranteed, though it will be called exactly once for each value.</li></ul></p>
</div>
<div id="fcn:map.zipmap" class="PFAfcndef">
{<b>"map.zipmap":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>Z</b></td></tr></table>
{<b>"map.zipmap":</b> [a, b, c, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>c</b></td><td>map of any <b>C</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>, <b>C</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>Z</b></td></tr></table>
{<b>"map.zipmap":</b> [a, b, c, d, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>c</b></td><td>map of any <b>C</b></td></tr><tr><td><b>d</b></td><td>map of any <b>D</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>Z</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to the elements of <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> in lock-step and return a result for row.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned maps" error if <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> do not all have the same keys.</li></ul></p>
</div>
<div id="fcn:map.zipmapWithKey" class="PFAfcndef">
{<b>"map.zipmapWithKey":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>, <b>B</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>Z</b></td></tr></table>
{<b>"map.zipmapWithKey":</b> [a, b, c, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>c</b></td><td>map of any <b>C</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>, <b>B</b>, <b>C</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>Z</b></td></tr></table>
{<b>"map.zipmapWithKey":</b> [a, b, c, d, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>c</b></td><td>map of any <b>C</b></td></tr><tr><td><b>d</b></td><td>map of any <b>D</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>) &rarr; any <b>Z</b></td></tr><tr><td><i>(returns)</i></td><td>map of <b>Z</b></td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">fcn</span> to the keys and elements of <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> in lock-step and return a result for row.</p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned maps" error if <span class="PFAp">a</span>, <span class="PFAp">b</span>, <span class="PFAp">c</span>, <span class="PFAp">d</span> do not all have the same keys.</li></ul></p>
</div>
<div id="fcn:map.corresponds" class="PFAfcndef">
{<b>"map.corresponds":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (<b>A</b>, <b>B</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">fcn</span> is <span class="PFAc">true</span> when applied to all pairs of values, one from <span class="PFAp">a</span> and the other from <span class="PFAp">b</span> (logical relation).</p>
<p><b>Details:</b><ul><li>The number of <span class="PFAp">fcn</span> calls is not guaranteed.</li><li>If the key sets of <span class="PFAp">a</span> and <span class="PFAp">b</span> are not equal, this function returns <span class="PFAc">false</span>.</li></ul></p>
</div>
<div id="fcn:map.correspondsWithKey" class="PFAfcndef">
{<b>"map.correspondsWithKey":</b> [a, b, fcn]} <br><table class="PFAwhere"><tr><td><b>a</b></td><td>map of any <b>A</b></td></tr><tr><td><b>b</b></td><td>map of any <b>B</b></td></tr><tr><td><b>fcn</b></td><td>function of (string, <b>A</b>, <b>B</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">fcn</span> is <span class="PFAc">true</span> when applied to all triples of key, value from <span class="PFAp">a</span>, value from <span class="PFAp">b</span> (logical relation).</p>
<p><b>Details:</b><ul><li>The number of <span class="PFAp">fcn</span> calls is not guaranteed.</li><li>If the key sets of <span class="PFAp">a</span> and <span class="PFAp">b</span> are not equal, this function returns <span class="PFAc">false</span>.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:bytes">bytes</h2></div>
<div id="fcn:bytes.len" class="PFAfcndef">
{<b>"bytes.len":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the length of byte array <span class="PFAp">x</span>.</p>
</div>
<div id="fcn:bytes.subseq" class="PFAfcndef">
{<b>"bytes.subseq":</b> [x, start, end]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Return the subsequence of <span class="PFAp">x</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive).</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li></ul></p>
</div>
<div id="fcn:bytes.subseqto" class="PFAfcndef">
{<b>"bytes.subseqto":</b> [x, start, end, replacement]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><b>start</b></td><td>int</td></tr><tr><td><b>end</b></td><td>int</td></tr><tr><td><b>replacement</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Replace <span class="PFAp">x</span> from <span class="PFAp">start</span> (inclusive) until <span class="PFAp">end</span> (exclusive) with <span class="PFAp">replacement</span>.</p>
<p><b>Details:</b><ul><li>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <span class="PFAp">end</span> ≤ <span class="PFAp">start</span> specifies a zero-length subsequence just before the <span class="PFAp">start</span> character.  All of these rules follow Python's slice behavior.</li></ul></p>
</div>
<div id="fcn:bytes.isAscii" class="PFAfcndef">
{<b>"bytes.isAscii":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"bytes.isAscii":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if <span class="PFAp">x</span> is valid ASCII; <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:bytes.isLatin1" class="PFAfcndef">
{<b>"bytes.isLatin1":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"bytes.isLatin1":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if <span class="PFAp">x</span> is valid latin-1 (ISO-8859-1); <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:bytes.isUtf8" class="PFAfcndef">
{<b>"bytes.isUtf8":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"bytes.isUtf8":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if <span class="PFAp">x</span> is valid utf-8; <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:bytes.isUtf16" class="PFAfcndef">
{<b>"bytes.isUtf16":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"bytes.isUtf16":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if <span class="PFAp">x</span> is valid utf-16 (byte order identified by optional byte-order mark); <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:bytes.isUtf16be" class="PFAfcndef">
{<b>"bytes.isUtf16be":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"bytes.isUtf16be":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if <span class="PFAp">x</span> is valid big endian utf-16; <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:bytes.isUtf16le" class="PFAfcndef">
{<b>"bytes.isUtf16le":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"bytes.isUtf16le":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if <span class="PFAp">x</span> is valid little endian utf-16; <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:bytes.decodeAscii" class="PFAfcndef">
{<b>"bytes.decodeAscii":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Decode a bytes object as an ASCII string.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid bytes" error if the bytes cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.decodeLatin1" class="PFAfcndef">
{<b>"bytes.decodeLatin1":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Decode a bytes object as a latin-1 (ISO-8859-1) string.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid bytes" error if the bytes cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.decodeUtf8" class="PFAfcndef">
{<b>"bytes.decodeUtf8":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Decode a bytes object as a utf-8 string.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid bytes" error if the bytes cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.decodeUtf16" class="PFAfcndef">
{<b>"bytes.decodeUtf16":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Decode a bytes object as a utf-16 (byte order identified by optional byte-order mark) string.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid bytes" error if the bytes cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.decodeUtf16be" class="PFAfcndef">
{<b>"bytes.decodeUtf16be":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Decode a bytes object as a big endian utf-16 string.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid bytes" error if the bytes cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.decodeUtf16le" class="PFAfcndef">
{<b>"bytes.decodeUtf16le":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Decode a bytes object as a little endian utf-16 string.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid bytes" error if the bytes cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.encodeAscii" class="PFAfcndef">
{<b>"bytes.encodeAscii":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode a string as ASCII bytes.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid string" error if the string cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.encodeLatin1" class="PFAfcndef">
{<b>"bytes.encodeLatin1":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode a string as latin-1 (ISO-8859-1) bytes.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid string" error if the string cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.encodeUtf8" class="PFAfcndef">
{<b>"bytes.encodeUtf8":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode a string as utf-8 bytes.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid string" error if the string cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.encodeUtf16" class="PFAfcndef">
{<b>"bytes.encodeUtf16":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode a string as utf-16 (byte order identified by optional byte-order mark) bytes.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid string" error if the string cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.encodeUtf16be" class="PFAfcndef">
{<b>"bytes.encodeUtf16be":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode a string as big endian utf-16 bytes.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid string" error if the string cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.encodeUtf16le" class="PFAfcndef">
{<b>"bytes.encodeUtf16le":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Encode a string as little endian utf-16 bytes.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid string" error if the string cannot be converted.</li></ul></p>
</div>
<div id="fcn:bytes.toBase64" class="PFAfcndef">
{<b>"bytes.toBase64":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Convert an arbitrary bytes object to a base64-encoded string.</p>
</div>
<div id="fcn:bytes.fromBase64" class="PFAfcndef">
{<b>"bytes.fromBase64":</b> [s]} <br><table class="PFAwhere"><tr><td><b>s</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Convert a base64-encoded string to a bytes object.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid base64" error if the string is not valid base64.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:fixed">fixed</h2></div>
<div id="fcn:fixed.toBytes" class="PFAfcndef">
{<b>"fixed.toBytes":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any fixed <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>bytes</td></tr></table>
<p><b>Description:</b> Convert fixed-length, named bytes into arbitrary-length, anonymous bytes.</p>
</div>
<div id="fcn:fixed.fromBytes" class="PFAfcndef">
{<b>"fixed.fromBytes":</b> [original, replacement]} <br><table class="PFAwhere"><tr><td><b>original</b></td><td>any fixed <b>A</b></td></tr><tr><td><b>replacement</b></td><td>bytes</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Overlay <span class="PFAp">replacement</span> on top of <span class="PFAp">original</span>.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">replacement</span> is shorter than <span class="PFAp">original</span>, the bytes beyond <span class="PFAp">replacement</span>'s length are taken from <span class="PFAp">original</span>.</li><li>If <span class="PFAp">replacement</span> is longer than <span class="PFAp">original</span>, the excess bytes are truncated.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:enum">enum</h2></div>
<div id="fcn:enum.toString" class="PFAfcndef">
{<b>"enum.toString":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>string</td></tr></table>
<p><b>Description:</b> Return the string representation of an enum.</p>
</div>
<div id="fcn:enum.toInt" class="PFAfcndef">
{<b>"enum.toInt":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the integer representation of an enum.</p>
</div>
<div id="fcn:enum.numSymbols" class="PFAfcndef">
{<b>"enum.numSymbols":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any enum <b>A</b></td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Return the number of symbols associated with this enum (a constant).</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:time">time</h2></div>
<div id="fcn:time.year" class="PFAfcndef">
{<b>"time.year":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the four-digit year that the timestamp falls within.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.monthOfYear" class="PFAfcndef">
{<b>"time.monthOfYear":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the month that the timestamp falls within, with 1 being January and 12 being December.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.dayOfYear" class="PFAfcndef">
{<b>"time.dayOfYear":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the day of the year that the timestamp falls within, from 1 to 355 or 356 inclusive, depending on leap year.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.dayOfMonth" class="PFAfcndef">
{<b>"time.dayOfMonth":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the day of the month that the timestamp falls within, a number from 1 to 28, 29, 30, or 31, inclusive, depending on month.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.dayOfWeek" class="PFAfcndef">
{<b>"time.dayOfWeek":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the day of the week that the timestamp falls within, with 0 being Monday and 6 being Sunday.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.hourOfDay" class="PFAfcndef">
{<b>"time.hourOfDay":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the hour of the day that the timestamp falls within, from 0 to 23 inclusive.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.minuteOfHour" class="PFAfcndef">
{<b>"time.minuteOfHour":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the minute of the hour that the timestamp falls within, from 0 to 59 inclusive.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.secondOfMinute" class="PFAfcndef">
{<b>"time.secondOfMinute":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Get the second of the minute that the timestamp falls within, from 0 to 59 inclusive.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.makeTimestamp" class="PFAfcndef">
{<b>"time.makeTimestamp":</b> [year, month, day, hour, minute, second, millisecond, zone]} <br><table class="PFAwhere"><tr><td><b>year</b></td><td>int</td></tr><tr><td><b>month</b></td><td>int</td></tr><tr><td><b>day</b></td><td>int</td></tr><tr><td><b>hour</b></td><td>int</td></tr><tr><td><b>minute</b></td><td>int</td></tr><tr><td><b>second</b></td><td>int</td></tr><tr><td><b>millisecond</b></td><td>int</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Given the date and time that this time occurs in, return the timestamp.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>year</b></td><td>The four-digit year.</td></tr>
<tr><td><b>month</b></td><td>The month of the year, from 1 to 12 inclusive.</td></tr>
<tr><td><b>day</b></td><td>The day of the month, from 1 to 28, 29, 30, or 31 inclusive, depending on month.</td></tr>
<tr><td><b>hour</b></td><td>The hour of the day, from 0 to 23 inclusive.</td></tr>
<tr><td><b>minute</b></td><td>The minute of the hour, from 0 to 59 inclusive.</td></tr>
<tr><td><b>second</b></td><td>The second of the minute, from 0 to 59 inclusive.</td></tr>
<tr><td><b>millisecond</b></td><td>The millisecond of the second, from 0 to 999 inclusive.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>The number of seconds since 1970 in UTC.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "timestamp undefined for given parameters" if any one (or more) of the inputs have impossible values.</li><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.isSecondOfMinute" class="PFAfcndef">
{<b>"time.isSecondOfMinute":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified number of seconds in any minute.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum number of seconds (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum number of seconds (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isMinuteOfHour" class="PFAfcndef">
{<b>"time.isMinuteOfHour":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified number of minutes in any hour.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum number of minutes (inclusive)</td></tr>
<tr><td><b>high</b></td><td>Maximum number of minutes (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isHourOfDay" class="PFAfcndef">
{<b>"time.isHourOfDay":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified number of hours in any day.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum number of hours (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum number of hours (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isDayOfWeek" class="PFAfcndef">
{<b>"time.isDayOfWeek":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified day of week range, with 0 being Monday and 6 being Sunday.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum day of the week (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum day of the week (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isDayOfMonth" class="PFAfcndef">
{<b>"time.isDayOfMonth":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified day of month range, with 1 being the first of the month..</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum day of the month (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum day of the month (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isMonthOfYear" class="PFAfcndef">
{<b>"time.isMonthOfYear":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified month of year range, with 1 being January and 12 being December.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum month of the year (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum month of the year (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isDayOfYear" class="PFAfcndef">
{<b>"time.isDayOfYear":</b> [ts, zone, low, high]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determines if a timestamp falls within a specified day of year range, with 1 being the first of the year.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
<tr><td><b>low</b></td><td>Minimum day of year (inclusive).</td></tr>
<tr><td><b>high</b></td><td>Maximum day of year (exclusive).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li><li>Raises "bad time range" if low \(\mathrm{low} \geq \mathrm{high}\).</li></ul></p>
</div>
<div id="fcn:time.isWeekend" class="PFAfcndef">
{<b>"time.isWeekend":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if the timestamp falls on a Saturday or Sunday, <span class="PFAc">false</span> otherwise.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="fcn:time.isWorkHours" class="PFAfcndef">
{<b>"time.isWorkHours":</b> [ts, zone]} <br><table class="PFAwhere"><tr><td><b>ts</b></td><td>double</td></tr><tr><td><b>zone</b></td><td>string</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Returns <span class="PFAc">true</span> if the timestamp falls between 9 am (inclusive) and 5 pm (exclusive) on Monday through Friday, otherwise <span class="PFAc">false</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>ts</b></td><td>Number of seconds since 1970 in UTC.</td></tr>
<tr><td><b>zone</b></td><td>Timezone name from the Olson timezone database, version 2015f (UTC if blank).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "unrecognized timezone string" if <span class="PFAp">zone</span> is not in the Olson 2015f database.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:impute">impute</h2></div>
<div id="fcn:impute.errorOnNull" class="PFAfcndef">
{<b>"impute.errorOnNull":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>union of {any <b>A</b>, null}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Skip an action by raising a runtime error when <span class="PFAp">x</span> is <span class="PFAc">null</span>.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "encountered null" error if <span class="PFAp">x</span> is <span class="PFAc">null</span>.</li></ul></p>
</div>
<div id="fcn:impute.defaultOnNull" class="PFAfcndef">
{<b>"impute.defaultOnNull":</b> [x, default]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>union of {any <b>A</b>, null}</td></tr><tr><td><b>default</b></td><td><b>A</b></td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Replace <span class="PFAc">null</span> values in <span class="PFAp">x</span> with <span class="PFAp">default</span>.</p>
</div>
<div id="fcn:impute.isnan" class="PFAfcndef">
{<b>"impute.isnan":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"impute.isnan":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is <span class="PFAc">nan</span>, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:impute.isinf" class="PFAfcndef">
{<b>"impute.isinf":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"impute.isinf":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is positive or negative infinity, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:impute.isnum" class="PFAfcndef">
{<b>"impute.isnum":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
{<b>"impute.isnum":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Return <span class="PFAc">true</span> if <span class="PFAp">x</span> is neither <span class="PFAc">nan</span> nor infinite, <span class="PFAc">false</span> otherwise.</p>
</div>
<div id="fcn:impute.errorOnNonNum" class="PFAfcndef">
{<b>"impute.errorOnNonNum":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
{<b>"impute.errorOnNonNum":</b> [x]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Pass through <span class="PFAp">x</span> if it is neither <span class="PFAc">nan</span> nor infinite, but raise an error otherwise.</p>
<p><b>Runtime Errors:</b><ul><li>Raises an "encountered nan" if <span class="PFAp">x</span> is <span class="PFAc">nan</span>.</li><li>Raises an "encountered +inf" if <span class="PFAp">x</span> is positive infinity.</li><li>Raises an "encountered -inf" if <span class="PFAp">x</span> is negative infinity.</li></ul></p>
</div>
<div id="fcn:impute.defaultOnNonNum" class="PFAfcndef">
{<b>"impute.defaultOnNonNum":</b> [x, default]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>float</td></tr><tr><td><b>default</b></td><td>float</td></tr><tr><td><i>(returns)</i></td><td>float</td></tr></table>
{<b>"impute.defaultOnNonNum":</b> [x, default]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>default</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Pass through <span class="PFAp">x</span> if it is neither <span class="PFAc">nan</span> nor infinite, and return <span class="PFAp">default</span> otherwise.</p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:interp">interp</h2></div>
<div id="fcn:interp.bin" class="PFAfcndef">
{<b>"interp.bin":</b> [x, numbins, low, high]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>numbins</b></td><td>int</td></tr><tr><td><b>low</b></td><td>double</td></tr><tr><td><b>high</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
{<b>"interp.bin":</b> [x, origin, width]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>origin</b></td><td>double</td></tr><tr><td><b>width</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>int</td></tr></table>
<p><b>Description:</b> Finds the bin that contains <span class="PFAp">x</span>, declared either as <span class="PFAp">numbins</span> between two endpoints or a bin <span class="PFAp">width</span> starting at some <span class="PFAp">origin</span>.</p>
<p><b>Details:</b><ul><li>Bins are inclusive on the low end and exclusive on the high end, so if <span class="PFAp">x</span> equal <span class="PFAp">low</span> or <span class="PFAp">origin</span>, the resulting bin is <span class="PFAc">0</span>, but if <span class="PFAp">x</span> is equal to <span class="PFAp">high</span>, it is out of range.</li><li>If the first signature is used, the resulting bin must be between <span class="PFAc">0</span> (inclusive) and <span class="PFAp">numbins</span> (exclusive). If the second signature is used, the resulting bin may be any integer, including negative numbers.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">low</span> is greater or equal to <span class="PFAp">high</span>, raises "bad histogram range"</li><li>If <span class="PFAp">numbins</span> is less than <span class="PFAc">1</span> or <span class="PFAp">width</span> is less or equal to <span class="PFAc">0</span>, raises "bad histogram scale"</li><li>If the first signature is used, raises "x out of range" if <span class="PFAp">x</span> is less than <span class="PFAp">low</span> or greater or equal to <span class="PFAp">high</span>.</li></ul></p>
</div>
<div id="fcn:interp.nearest" class="PFAfcndef">
{<b>"interp.nearest":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: any <b>T</b>}</td></tr><tr><td><i>(returns)</i></td><td><b>T</b></td></tr></table>
{<b>"interp.nearest":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: array of double, <i>to</i>: any <b>T</b>}</td></tr><tr><td><i>(returns)</i></td><td><b>T</b></td></tr></table>
{<b>"interp.nearest":</b> [x, table, metric]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>X1</b></td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: any <b>X2</b>, <i>to</i>: any <b>T</b>}</td></tr><tr><td><b>metric</b></td><td>function of (<b>X1</b>, <b>X2</b>) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td><b>T</b></td></tr></table>
<p><b>Description:</b> Finds the closest <span class="PFApf">x</span> value in the <span class="PFAp">table</span> to the input <span class="PFAp">x</span> and returns the corresponding <span class="PFApf">to</span> value.</p>
<p><b>Details:</b><ul><li>Any ties in distance are resolved in favor of the first instance in the <span class="PFAp">table</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "table must have at least one entry" error if <span class="PFAp">table</span> has fewer than one entry.</li><li>Raises an "inconsistent dimensionality" error if any input <span class="PFAp">x</span> and record <span class="PFApf">x</span> have different numbers of dimensions.</li></ul></p>
</div>
<div id="fcn:interp.linear" class="PFAfcndef">
{<b>"interp.linear":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"interp.linear":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
<p><b>Description:</b> Finds the closest <span class="PFApf">x</span> values in the <span class="PFAp">table</span> that are below and above the input <span class="PFAp">x</span> and linearly projects their <span class="PFApf">to</span> values to the input <span class="PFAp">x</span>.</p>
<p><b>Details:</b><ul><li>Any ties in distance are resolved in favor of the first instance in the <span class="PFAp">table</span>.</li><li>If the <span class="PFApf">to</span> values are arrays, each component will be interpolated.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "table must have at least two distinct x values" error if fewer than two of the <span class="PFAp">table</span> <span class="PFApf">x</span> entries are unique.</li><li>Raises an "inconsistent dimensionality" error if the <span class="PFApf">to</span> values of the two closest entries have different numbers of dimensions.</li></ul></p>
</div>
<div id="fcn:interp.linearFlat" class="PFAfcndef">
{<b>"interp.linearFlat":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"interp.linearFlat":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
<p><b>Description:</b> Like <span class="PFAf">interp.linear</span>, but returns the closest entry's <span class="PFApf">to</span> if the input <span class="PFAp">x</span> is beyond the <span class="PFAp">table</span>.</p>
<p><b>Details:</b><ul><li>Any ties in distance are resolved in favor of the first instance in the <span class="PFAp">table</span>.</li><li>If the <span class="PFApf">to</span> values are arrays, each component will be interpolated.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "table must have at least two entries" error if <span class="PFAp">table</span> has fewer than two entries.</li><li>Raises an "inconsistent dimensionality" error if the <span class="PFApf">to</span> values of the two closest entries have different numbers of dimensions.</li></ul></p>
</div>
<div id="fcn:interp.linearMissing" class="PFAfcndef">
{<b>"interp.linearMissing":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>union of {null, double}</td></tr></table>
{<b>"interp.linearMissing":</b> [x, table]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>table</b></td><td>array of any record <b>R</b> with fields {<i>x</i>: double, <i>to</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td>union of {null, array of double}</td></tr></table>
<p><b>Description:</b> Like <span class="PFAf">interp.linear</span>, but returns a missing value (<span class="PFAc">null</span>) if the input <span class="PFAp">x</span> is beyond the <span class="PFAp">table</span>.</p>
<p><b>Details:</b><ul><li>Any ties in distance are resolved in favor of the first instance in the <span class="PFAp">table</span>.</li><li>If the <span class="PFApf">to</span> values are arrays, each component will be interpolated.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "table must have at least two entries" error if <span class="PFAp">table</span> has fewer than two entries.</li><li>Raises an "inconsistent dimensionality" error if the <span class="PFApf">to</span> values of the two closest entries have different numbers of dimensions.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:prob.dist">prob.dist</h2></div>
<div id="fcn:prob.dist.gaussianLL" class="PFAfcndef">
{<b>"prob.dist.gaussianLL":</b> [x, mu, sigma]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>mu</b></td><td>double</td></tr><tr><td><b>sigma</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"prob.dist.gaussianLL":</b> [x, params]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>params</b></td><td>any record <b>A</b> with fields {<i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the log-likelihood of a Gaussian (normal) distribution parameterized by <span class="PFAp">mu</span> and <span class="PFAp">sigma</span> or a record <span class="PFAp">params</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the log-likelihood.</td></tr>
<tr><td><b>mu</b></td><td>Centroid of the distribution (same as <span class="PFApf">mean</span>).</td></tr>
<tr><td><b>sigma</b></td><td>Width of the distribution (same as the square root of <span class="PFApf">variance</span>).</td></tr>
<tr><td><b>params</b></td><td>Alternate way of specifying the parameters of the distribution; this record could be created by <span class="PFAf">stat.sample.update</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(\mu\) = <span class="PFAp">mu</span> or <span class="PFApf">mean</span> and \(\sigma\) = <span class="PFAp">sigma</span> or the square root of <span class="PFApf">variance</span>, this function returns \(-(x - \mu)^2/(2 \sigma^2) - \log(\sigma \sqrt{2\pi})\).</td></tr>
</table></p>
</div>
<div id="fcn:prob.dist.gaussianCDF" class="PFAfcndef">
{<b>"prob.dist.gaussianCDF":</b> [x, mu, sigma]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>mu</b></td><td>double</td></tr><tr><td><b>sigma</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"prob.dist.gaussianCDF":</b> [x, params]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>params</b></td><td>any record <b>A</b> with fields {<i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the cumultive distribution function (CDF) for the normal distribution, parameterized by <span class="PFAp">mu</span> and <span class="PFAp">sigma</span> or a record <span class="PFAp">params</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>mu</b></td><td>Centroid of the distribution (same as <span class="PFApf">mean</span>).</td></tr>
<tr><td><b>sigma</b></td><td>Width of the distribution (same as the square root of <span class="PFApf">variance</span>).</td></tr>
<tr><td><b>params</b></td><td>Alternate way of specifying the parameters of the distribution; this record could be created by <span class="PFAf">stat.sample.update</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(\mu\) = <span class="PFAp">mu</span> or <span class="PFApf">mean</span> and \(\sigma\) = <span class="PFAp">sigma</span> or the square root of <span class="PFApf">variance</span>, this function returns \(0.5 * ( 1.0 + \mathrm{Erf}(\frac{x - \mu}{\sigma \sqrt{2}}))\).</td></tr>
</table></p>
</div>
<div id="fcn:prob.dist.gaussianQF" class="PFAfcndef">
{<b>"prob.dist.gaussianQF":</b> [p, mu, sigma]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>mu</b></td><td>double</td></tr><tr><td><b>sigma</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"prob.dist.gaussianQF":</b> [p, params]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>params</b></td><td>any record <b>A</b> with fields {<i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the normal quantile (QF, the inverse of the CDF) parameterized by <span class="PFAp">mu</span> and <span class="PFAp">sigma</span> or a record <span class="PFAp">params</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Probability at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>mu</b></td><td>Centroid of the distribution (same as <span class="PFApf">mean</span>).</td></tr>
<tr><td><b>sigma</b></td><td>Width of the distribution (same as the square root of <span class="PFApf">variance</span>).</td></tr>
<tr><td><b>params</b></td><td>Alternate way of specifying the parameters of the distribution; this record could be created by <span class="PFAf">stat.sample.update</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(\mu\) = <span class="PFAp">mu</span> or <span class="PFApf">mean</span> and \(\sigma\) = <span class="PFAp">sigma</span> or the square root of <span class="PFApf">variance</span>, this function returns \(\mu + \sigma \sqrt{2} \mathrm{Erf}^{-1} (2p - 1)\).</td></tr>
</table></p>
</div>
<div id="fcn:prob.dist.exponentialPDF" class="PFAfcndef">
{<b>"prob.dist.exponentialPDF":</b> [x, lambda]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>lambda</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the exponential distribution parameterized by <span class="PFAp">lambda</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>lambda</b></td><td>Rate parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(lambda\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\lambda \mathrm{e}^{- \lambda x}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(lambda < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.exponentialCDF" class="PFAfcndef">
{<b>"prob.dist.exponentialCDF":</b> [x, lambda]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>lambda</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the exponential distribution parameterized by <span class="PFAp">lambda</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>lambda</b></td><td>Rate parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(lambda\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(lambda < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.exponentialQF" class="PFAfcndef">
{<b>"prob.dist.exponentialQF":</b> [p, lambda]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>lambda</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the exponential distribution parameterized by <span class="PFAp">lambda</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>lambda</b></td><td>Rate parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(lambda\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(lambda < 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.chi2PDF" class="PFAfcndef">
{<b>"prob.dist.chi2PDF":</b> [x, df]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>df</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the Chi-squared distribution parameterized by its degrees of freedom <span class="PFAp">df</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>df</b></td><td>Degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{1}{2^{\frac{\mathrm{df}}{2}} \Gamma(\frac{\mathrm{df}}{2})} x^{\frac{\mathrm{df}}{2}-1}\mathrm{e}^{-\frac{x}{2}}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if <span class="PFAp">df</span> &lt; 0.</li></ul></p>
</div>
<div id="fcn:prob.dist.chi2CDF" class="PFAfcndef">
{<b>"prob.dist.chi2CDF":</b> [x, df]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>df</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the Chi-squared distribution parameterized by its degrees of freedom <span class="PFAp">df</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>df</b></td><td>Degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(x1\), \(x1\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if <span class="PFAp">df</span> &lt; 0.</li></ul></p>
</div>
<div id="fcn:prob.dist.chi2QF" class="PFAfcndef">
{<b>"prob.dist.chi2QF":</b> [p, df]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>df</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the Chi-squared distribution parameterized by its degrees of freedom <span class="PFAp">df</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>df</b></td><td>Degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(x1\), \(x1\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if <span class="PFAp">df</span> &lt; 0.</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.poissonPDF" class="PFAfcndef">
{<b>"prob.dist.poissonPDF":</b> [k, lambda]} <br><table class="PFAwhere"><tr><td><b>k</b></td><td>int</td></tr><tr><td><b>lambda</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the poisson distribution parameterized by <span class="PFAp">lambda</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>lambda</b></td><td>Mean and variance parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(lambda\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{\lambda^{x}}{x!} \mathrm{e}^{-\lambda}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(lambda < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.poissonCDF" class="PFAfcndef">
{<b>"prob.dist.poissonCDF":</b> [k, lambda]} <br><table class="PFAwhere"><tr><td><b>k</b></td><td>double</td></tr><tr><td><b>lambda</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the poisson distribution parameterized by <span class="PFAp">lambda</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>lambda</b></td><td>Mean and variance parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(lambda\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(lambda < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.poissonQF" class="PFAfcndef">
{<b>"prob.dist.poissonQF":</b> [p, lambda]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>lambda</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the poisson distribution parameterized by <span class="PFAp">lambda</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>lambda</b></td><td>Mean and variance parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(lambda\), \(lambda\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(lambda < 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.gammaPDF" class="PFAfcndef">
{<b>"prob.dist.gammaPDF":</b> [x, shape, scale]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>shape</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the gamma distribution parameterized by <span class="PFAp">shape</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>shape</b></td><td>Shape parameter (a).</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter (s).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape\), \(scale\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{1}{s^{a} \Gamma(a)} x^{a - 1} \mathrm{e}^{-\frac{x}{s}}  \).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(shape < 0\) OR if \(scale < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.gammaCDF" class="PFAfcndef">
{<b>"prob.dist.gammaCDF":</b> [x, shape, scale]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>shape</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the gamma distribution parameterized by <span class="PFAp">shape</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>shape</b></td><td>Shape parameter.</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape\), \(scale\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x)~= P(X~\leq~x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(shape < 0\) OR if \(scale < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.gammaQF" class="PFAfcndef">
{<b>"prob.dist.gammaQF":</b> [p, shape, scale]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>shape</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the gamma distribution parameterized by <span class="PFAp">shape</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>shape</b></td><td>Shape parameter.</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape\), \(scale\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x)~:= P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(shape < 0\) OR if \(scale < 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.betaPDF" class="PFAfcndef">
{<b>"prob.dist.betaPDF":</b> [x, shape1, shape2]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>shape1</b></td><td>double</td></tr><tr><td><b>shape2</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the beta distribution parameterized by <span class="PFAp">shape1</span> and <span class="PFAp">shape2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF, defined between zero and one.</td></tr>
<tr><td><b>shape1</b></td><td>First shape parameter (a).</td></tr>
<tr><td><b>shape2</b></td><td>Second shape parameter (b).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape1\), \(shape2\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{\Gamma(a + n)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(a \leq 0\) OR if \(b \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.betaCDF" class="PFAfcndef">
{<b>"prob.dist.betaCDF":</b> [x, shape1, shape2]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>shape1</b></td><td>double</td></tr><tr><td><b>shape2</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the beta distribution parameterized by <span class="PFAp">shape1</span> and <span class="PFAp">shape2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>shape1</b></td><td>First shape parameter (a).</td></tr>
<tr><td><b>shape2</b></td><td>Second shape parameter (b).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape1\), \(shape2\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(a \leq 0\) OR if \(b \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.betaQF" class="PFAfcndef">
{<b>"prob.dist.betaQF":</b> [p, shape1, shape2]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>shape1</b></td><td>double</td></tr><tr><td><b>shape2</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the beta distribution parameterized by <span class="PFAp">shape1</span> and <span class="PFAp">shape2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>shape1</b></td><td>First shape parameter.</td></tr>
<tr><td><b>shape2</b></td><td>Second shape parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape1\), \(shape2\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(a \leq 0\) OR if \(b \leq 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.cauchyPDF" class="PFAfcndef">
{<b>"prob.dist.cauchyPDF":</b> [x, location, scale]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>location</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the cauchy distribution parameterized by <span class="PFAp">location</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>location</b></td><td>Location parameter (l).</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter (s).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(location\), \(scale\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{1}{(\pi s (1 + (\frac{x - l}{s})^{2})) }\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(scale \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.cauchyCDF" class="PFAfcndef">
{<b>"prob.dist.cauchyCDF":</b> [x, location, scale]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>location</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the cauchy distribution parameterized by <span class="PFAp">location</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>location</b></td><td>Location parameter.</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(location\), \(scale\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(scale \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.cauchyQF" class="PFAfcndef">
{<b>"prob.dist.cauchyQF":</b> [p, location, scale]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>location</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the cauchy distribution parameterized by <span class="PFAp">location</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>location</b></td><td>Location parameter.</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(location\), \(scale\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(scale \leq 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.fPDF" class="PFAfcndef">
{<b>"prob.dist.fPDF":</b> [x, df1, df2]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>df1</b></td><td>int</td></tr><tr><td><b>df2</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the F distribution parameterized by <span class="PFAp">df1</span> and <span class="PFAp">df2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>df1</b></td><td>Numerator degrees of freedom parameter (d1).</td></tr>
<tr><td><b>df2</b></td><td>Denominator degrees of freedom parameter (d2).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df1\), \(df2\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{\Gamma(\frac{d1 + d2}{2})}{\Gamma(\frac{d1}{2})\Gamma(\frac{d2}{2})} \frac{d1}{d2}^{\frac{d1}{2}-1}(1 + \frac{d1}{d2} x)^{-\frac{d1 + d2}{2}}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(df1 \leq 0\) OR if \(df2 \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.fCDF" class="PFAfcndef">
{<b>"prob.dist.fCDF":</b> [x, df1, df2]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>df1</b></td><td>int</td></tr><tr><td><b>df2</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the F distribution parameterized by <span class="PFAp">df1</span> and <span class="PFAp">df2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>df1</b></td><td>Numerator degrees of freedom parameter.</td></tr>
<tr><td><b>df2</b></td><td>Denominator degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df1\), \(df2\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(df1 \leq 0\) OR if \(df2 \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.fQF" class="PFAfcndef">
{<b>"prob.dist.fQF":</b> [p, df1, df2]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>df1</b></td><td>int</td></tr><tr><td><b>df2</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the F distribution parameterized by <span class="PFAp">df1</span> and <span class="PFAp">df2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>df1</b></td><td>Numerator degrees of freedom parameter.</td></tr>
<tr><td><b>df2</b></td><td>Denominator degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df1\), \(df2\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(df1 \leq 0\) OR if \(df2 \leq 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.lognormalPDF" class="PFAfcndef">
{<b>"prob.dist.lognormalPDF":</b> [x, meanlog, sdlog]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>meanlog</b></td><td>double</td></tr><tr><td><b>sdlog</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the lognormal distribution parameterized by <span class="PFAp">meanlog</span> and <span class="PFAp">sdlog</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>meanlog</b></td><td>Mean of the distribution on the log scale (\(\mu\)).</td></tr>
<tr><td><b>sdlog</b></td><td>Standard deviation of the distribution on the log scale (\(\sigma\)).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(meanlog\), \(sdlog\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{1}{\sqrt{2 \pi} \sigma x} \mathrm{e}^{-\frac{\mathrm{log}(x) - \mu}{2 \sigma^{2}}}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(sdlog \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.lognormalCDF" class="PFAfcndef">
{<b>"prob.dist.lognormalCDF":</b> [x, meanlog, sdlog]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>meanlog</b></td><td>double</td></tr><tr><td><b>sdlog</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the lognormal distribution parameterized by <span class="PFAp">meanlog</span> and <span class="PFAp">sdlog</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>meanlog</b></td><td>Mean of the distribution on the log scale.</td></tr>
<tr><td><b>sdlog</b></td><td>Standard deviation of the distribution on the log scale.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(meanlog\), \(sdlog\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(sdlog \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.lognormalQF" class="PFAfcndef">
{<b>"prob.dist.lognormalQF":</b> [p, meanlog, sdlog]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>meanlog</b></td><td>double</td></tr><tr><td><b>sdlog</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the lognormal distribution parameterized by <span class="PFAp">meanlog</span> and <span class="PFAp">sdlog</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>meanlog</b></td><td>Mean of the distribution on the log scale.</td></tr>
<tr><td><b>sdlog</b></td><td>Standard deviation of the distribution on the log scale.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(meanlog\), \(sdlog\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(sdlog \leq 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.tPDF" class="PFAfcndef">
{<b>"prob.dist.tPDF":</b> [x, df]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>df</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the student's t distribution parameterized by <span class="PFAp">df</span> and <span class="PFAp">x2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>df</b></td><td>Degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{\Gamma(\frac{\mathrm{df}+1}{2})}{\sqrt{\mathrm{df}\pi} \Gamma{\frac{\mathrm{df}}{2}}}(1 + x^{\frac{2}{n}})^{-\frac{\mathrm{df} + 1}{2}}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(df \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.tCDF" class="PFAfcndef">
{<b>"prob.dist.tCDF":</b> [x, df]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>df</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the student's t distribution parameterized by <span class="PFAp">df</span> and <span class="PFAp">x2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>df</b></td><td>Degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(df \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.tQF" class="PFAfcndef">
{<b>"prob.dist.tQF":</b> [p, df]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>df</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the student's t distribution parameterized by <span class="PFAp">df</span> and <span class="PFAp">x2</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>df</b></td><td>Degrees of freedom parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(df\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(df \leq 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.binomialPDF" class="PFAfcndef">
{<b>"prob.dist.binomialPDF":</b> [x, size, prob]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the binomial distribution parameterized by <span class="PFAp">size</span> and <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>size</b></td><td>The number of trials (n).</td></tr>
<tr><td><b>prob</b></td><td>The probability of success in each trial (p).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(size\), \(prob\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\mathrm{choose}(n, x) p^{x} (1 - p)^{n - x}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(size < 0\) OR if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.binomialCDF" class="PFAfcndef">
{<b>"prob.dist.binomialCDF":</b> [x, size, prob]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the binomial distribution parameterized by <span class="PFAp">size</span> and <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>size</b></td><td>The number of trials.</td></tr>
<tr><td><b>prob</b></td><td>The probability of success in each trial.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(size\), \(prob\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(size < 0\) OR if \(prob < 0\) OR if \(prob > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.binomialQF" class="PFAfcndef">
{<b>"prob.dist.binomialQF":</b> [p, size, prob]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the binomial distribution parameterized by <span class="PFAp">size</span> and <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>size</b></td><td>The number of trials.</td></tr>
<tr><td><b>prob</b></td><td>The probability of success in each trial.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(size\), \(prob\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x)~:= P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(size < 0\) OR if \(prob < 0\) OR if \(prob > 1\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.uniformPDF" class="PFAfcndef">
{<b>"prob.dist.uniformPDF":</b> [x, min, max]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>min</b></td><td>double</td></tr><tr><td><b>max</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the uniform distribution parameterized by <span class="PFAp">min</span> and <span class="PFAp">max</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>min</b></td><td>Lower bound.</td></tr>
<tr><td><b>max</b></td><td>Upper bound.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(min\), \(max\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{1}{\mathrm{max} - \mathrm{min}}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(min \geq max\).</li></ul></p>
</div>
<div id="fcn:prob.dist.uniformCDF" class="PFAfcndef">
{<b>"prob.dist.uniformCDF":</b> [x, min, max]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>min</b></td><td>double</td></tr><tr><td><b>max</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the uniform distribution parameterized by <span class="PFAp">min</span> and <span class="PFAp">max</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>min</b></td><td>Lower bound.</td></tr>
<tr><td><b>max</b></td><td>Upper bound.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(min\), \(max\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(min \geq max\).</li></ul></p>
</div>
<div id="fcn:prob.dist.uniformQF" class="PFAfcndef">
{<b>"prob.dist.uniformQF":</b> [p, min, max]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>min</b></td><td>double</td></tr><tr><td><b>max</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the uniform distribution parameterized by <span class="PFAp">min</span> and <span class="PFAp">max</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>min</b></td><td>Lower bound.</td></tr>
<tr><td><b>max</b></td><td>Upper bound.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(min\), \(max\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(min \geq max\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.geometricPDF" class="PFAfcndef">
{<b>"prob.dist.geometricPDF":</b> [x, prob]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the geometric distribution parameterized by <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>prob</b></td><td>Probability of success of each trial (p).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(prob\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(p (1 - p)^{x}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(\mathrm{prob} \leq 0\) OR if \(\mathrm{prob} > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.geometricCDF" class="PFAfcndef">
{<b>"prob.dist.geometricCDF":</b> [x, prob]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the geometric distribution parameterized by <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>prob</b></td><td>Probability of success of each trial.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(prob\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(\mathrm{prob} \leq 0\) OR if \(\mathrm{prob} > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.geometricQF" class="PFAfcndef">
{<b>"prob.dist.geometricQF":</b> [p, prob]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the geometric distribution parameterized by <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>prob</b></td><td>Probability of success of each trial.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(prob\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(\mathrm{prob} \leq 0\) OR if \(\mathrm{prob} > 1\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.hypergeometricPDF" class="PFAfcndef">
{<b>"prob.dist.hypergeometricPDF":</b> [x, m, n, k]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>m</b></td><td>int</td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>k</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the hypergeometric distribution parameterized by <span class="PFAp">m</span>, <span class="PFAp">n</span> and <span class="PFAp">k</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>The number of white balls drawn without replacement from the urn.</td></tr>
<tr><td><b>m</b></td><td>The number of white balls in the urn.</td></tr>
<tr><td><b>n</b></td><td>The number of black balls in the urn.</td></tr>
<tr><td><b>k</b></td><td>The number of balls drawn from the urn.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(m\), \(n\) and \(k\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{\mathrm{choose}(m, x) \mathrm{choose}(n, k-x)}{\mathrm{choose}(m+n, k)} \). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(\mathrm{m} + \mathrm{n} > \mathrm{k}\).</li></ul></p>
</div>
<div id="fcn:prob.dist.hypergeometricCDF" class="PFAfcndef">
{<b>"prob.dist.hypergeometricCDF":</b> [x, m, n, k]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>m</b></td><td>int</td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>k</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the hypergeometric distribution parameterized by <span class="PFAp">m</span>, <span class="PFAp">n</span> and <span class="PFAp">k</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>The number of white balls drawn without replacement.</td></tr>
<tr><td><b>m</b></td><td>The number of white balls in the urn.</td></tr>
<tr><td><b>n</b></td><td>The number of black balls in the urn.</td></tr>
<tr><td><b>k</b></td><td>The number of balls drawn from the urn.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(m\), \(n\) and \(k\) at \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(\mathrm{m} + \mathrm{n} > \mathrm{k}\).</li></ul></p>
</div>
<div id="fcn:prob.dist.hypergeometricQF" class="PFAfcndef">
{<b>"prob.dist.hypergeometricQF":</b> [p, m, n, k]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>m</b></td><td>int</td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>k</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the hypergeometric distribution parameterized by <span class="PFAp">m</span>, <span class="PFAp">n</span> and <span class="PFAp">k</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>m</b></td><td>The number of white balls in the urn.</td></tr>
<tr><td><b>n</b></td><td>The number of black balls in the urn.</td></tr>
<tr><td><b>k</b></td><td>The number of balls drawn from the urn.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(m\), \(n\) and \(k\) at \(p\), this function returns the value \(x\) such that \(F_{X}(x)~:= P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(\mathrm{m} + \mathrm{n} > \mathrm{k}\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.weibullPDF" class="PFAfcndef">
{<b>"prob.dist.weibullPDF":</b> [x, shape, scale]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>shape</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the weibull distribution parameterized by <span class="PFAp">shape</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF.</td></tr>
<tr><td><b>shape</b></td><td>Shape parameter (a).</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter (b).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape\), \(scale\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{a}{b}(\frac{x}{b})^{a - 1}\mathrm{e}^{-(\frac{x}{b})^{a}}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(shape \leq 0\) OR if \(scale \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.weibullCDF" class="PFAfcndef">
{<b>"prob.dist.weibullCDF":</b> [x, shape, scale]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>shape</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the weibull distribution parameterized by <span class="PFAp">shape</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>shape</b></td><td>Shape parameter.</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape\), \(scale\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X~\leq~x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(shape \leq 0\) OR if \(scale \leq 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.weibullQF" class="PFAfcndef">
{<b>"prob.dist.weibullQF":</b> [p, shape, scale]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>shape</b></td><td>double</td></tr><tr><td><b>scale</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the weibull distribution parameterized by <span class="PFAp">shape</span> and <span class="PFAp">scale</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>shape</b></td><td>Shape parameter.</td></tr>
<tr><td><b>scale</b></td><td>Scale parameter.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(shape\), \(scale\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X~\leq~x)~=~p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if the \(shape \leq 0\) OR if \(scale \leq 0\).</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="fcn:prob.dist.negativeBinomialPDF" class="PFAfcndef">
{<b>"prob.dist.negativeBinomialPDF":</b> [x, size, prob]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>int</td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the density (PDF) of the negative binomial distribution parameterized by <span class="PFAp">size</span> and <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the PDF (integer) .</td></tr>
<tr><td><b>size</b></td><td>Size parameter (integer).  Target number of successful trials (n).</td></tr>
<tr><td><b>prob</b></td><td>Probability of success in each trial (p).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(size\), \(prob\) and \(x\), this function evaluates the probability density function at \(x\).  The PDF implemented is \(\frac{\Gamma(x+n)}{\Gamma(n) x!} p^{n} (1-p)^{x}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(\mathrm{prob} < 0\) OR if \(\mathrm{prob} > 1\).</li><li>Raises "invalid parameterization" if \(size < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.negativeBinomialCDF" class="PFAfcndef">
{<b>"prob.dist.negativeBinomialCDF":</b> [x, size, prob]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the distribution function (CDF) of the negative binomial distribution parameterized by <span class="PFAp">size</span> and <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value at which to compute the CDF.</td></tr>
<tr><td><b>size</b></td><td>Size parameter (integer).  Target number of successful trials.</td></tr>
<tr><td><b>prob</b></td><td>Probability of success in each trial.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(size\), \(prob\) and \(x\), this function returns the value \(p\) where \(p = F_{X}(x) = P(X \leq x)\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(\mathrm{prob} < 0\) OR if \(\mathrm{prob} > 1\).</li><li>Raises "invalid parameterization" if \(size < 0\).</li></ul></p>
</div>
<div id="fcn:prob.dist.negativeBinomialQF" class="PFAfcndef">
{<b>"prob.dist.negativeBinomialQF":</b> [p, size, prob]} <br><table class="PFAwhere"><tr><td><b>p</b></td><td>double</td></tr><tr><td><b>size</b></td><td>int</td></tr><tr><td><b>prob</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compute the quantile function (QF) of the negative binomial distribution parameterized by <span class="PFAp">size</span> and <span class="PFAp">prob</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>p</b></td><td>Value at which to compute the QF.  Must be a value between 0 and 1.</td></tr>
<tr><td><b>size</b></td><td>Size parameter (integer).  Target number of successful trials.</td></tr>
<tr><td><b>prob</b></td><td>Probability of success in each trial.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>With \(size\), \(prob\) and \(p\), this function returns the value \(x\) such that \(F_{X}(x) := P(X \leq x) = p\). </td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if \(\mathrm{prob} < 0\) OR if \(\mathrm{prob} > 1\).</li><li>Raises "invalid parameterization" if \(size \leq 0\) OR if \(size\) is not an integer.</li><li>Raises "invalid input" if \(p < 0\) OR if \(p > 1\).</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:test">test</h2></div>
<div id="fcn:test.kolmogorov" class="PFAfcndef">
{<b>"test.kolmogorov":</b> [x, y]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>y</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compare two datasets using the Kolmogorov-Smirnov test to determine if they might have been drawn from the same parent distribution.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>A bag of data.</td></tr>
<tr><td><b>y</b></td><td>Another bag of data.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a value between 0.0 and 1.0 representing the cumulative probability that <span class="PFAp">x</span> and <span class="PFAp">y</span> were drawn from the same distribution: 1.0 indicates a perfect match.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If both datasets are empty, this function returns 1.0</li></ul></p>
</div>
<div id="fcn:test.residual" class="PFAfcndef">
{<b>"test.residual":</b> [observation, prediciton]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>double</td></tr><tr><td><b>prediciton</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"test.residual":</b> [observation, prediciton]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>array of double</td></tr><tr><td><b>prediciton</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"test.residual":</b> [observation, prediciton]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>map of double</td></tr><tr><td><b>prediciton</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Compare an observation with its prediction by element-wise subtraction.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>observation</b></td><td>Scalar or vector of observations.</td></tr>
<tr><td><b>prediction</b></td><td>Scalar or vector of predictions.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Scalar or vector of <span class="PFAp">observation</span> minus <span class="PFAp">prediction</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned prediction" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">observation</span>.</li></ul></p>
</div>
<div id="fcn:test.pull" class="PFAfcndef">
{<b>"test.pull":</b> [observation, prediciton, uncertainty]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>double</td></tr><tr><td><b>prediciton</b></td><td>double</td></tr><tr><td><b>uncertainty</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"test.pull":</b> [observation, prediciton, uncertainty]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>array of double</td></tr><tr><td><b>prediciton</b></td><td>array of double</td></tr><tr><td><b>uncertainty</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"test.pull":</b> [observation, prediciton, uncertainty]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>map of double</td></tr><tr><td><b>prediciton</b></td><td>map of double</td></tr><tr><td><b>uncertainty</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>observation</b></td><td>Scalar or vector of observations.</td></tr>
<tr><td><b>prediction</b></td><td>Scalar or vector of predictions.</td></tr>
<tr><td><b>uncertainty</b></td><td>Scalar or vector of predictions.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Scalar or vector of <span class="PFAp">observation</span> minus <span class="PFAp">prediction</span> divided by <span class="PFAp">uncertainty</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned prediction" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">observation</span>.</li><li>Raises a "misaligned uncertainty" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">uncertainty</span>.</li></ul></p>
</div>
<div id="fcn:test.mahalanobis" class="PFAfcndef">
{<b>"test.mahalanobis":</b> [observation, prediction, covariance]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>array of double</td></tr><tr><td><b>prediction</b></td><td>array of double</td></tr><tr><td><b>covariance</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"test.mahalanobis":</b> [observation, prediction, covariance]} <br><table class="PFAwhere"><tr><td><b>observation</b></td><td>map of double</td></tr><tr><td><b>prediction</b></td><td>map of double</td></tr><tr><td><b>covariance</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>observation</b></td><td>Vector of observations \(\vec{o}\).</td></tr>
<tr><td><b>prediction</b></td><td>Vector of predictions \(\vec{p}\).</td></tr>
<tr><td><b>covariance</b></td><td>Matrix of covariance \(C\).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Scalar result of a similarity transformation: \(\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "too few rows/cols" error if <span class="PFAp">observation</span> has fewer than one element.</li><li>Raises a "misaligned prediction" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">observation</span>.</li><li>Raises a "misaligned covariance" error if <span class="PFAp">covariance</span> does not have the same indexes as <span class="PFAp">observation</span>.</li></ul></p>
</div>
<div id="fcn:test.updateChi2" class="PFAfcndef">
{<b>"test.updateChi2":</b> [pull, state]} <br><table class="PFAwhere"><tr><td><b>pull</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"test.updateChi2":</b> [pull, state]} <br><table class="PFAwhere"><tr><td><b>pull</b></td><td>array of double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"test.updateChi2":</b> [pull, state]} <br><table class="PFAwhere"><tr><td><b>pull</b></td><td>map of double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a chi-square calculation.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>pull</b></td><td>Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">chi2</span> and <span class="PFApf">DOF</span>.</td></tr>
</table></p>
</div>
<div id="fcn:test.reducedChi2" class="PFAfcndef">
{<b>"test.reducedChi2":</b> [state]} <br><table class="PFAwhere"><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the reduced chi-square, which is <span class="PFApf">chi2</span>/<span class="PFApf">DOF</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>state</b></td><td>Record of the <span class="PFApf">chi2</span> and <span class="PFApf">DOF</span>.</td></tr>
</table></p>
</div>
<div id="fcn:test.chi2Prob" class="PFAfcndef">
{<b>"test.chi2Prob":</b> [state]} <br><table class="PFAwhere"><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the chi-square probability, which is the CDF of the chi-square function.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>state</b></td><td>Record of the <span class="PFApf">chi2</span> and <span class="PFApf">DOF</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if <span class="PFApf">DOF</span> is less than zero.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:stat.sample">stat.sample</h2></div>
<div id="fcn:stat.sample.update" class="PFAfcndef">
{<b>"stat.sample.update":</b> [x, w, state]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>count</i>: double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a counter, a counter and a mean, or a counter, mean, and variance.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>w</b></td><td>Sample weight; set to 1 for no weights.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and/or <span class="PFApf">variance</span>.
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>count</b></td><td>The sum of weights <span class="PFAp">w</span>.</td></tr>
<tr><td><b>mean</b></td><td>The mean of <span class="PFAp">x</span>, weighted by <span class="PFAp">w</span>.  This field is optional, but if provided, it must be a <span class="PFAc">double</span>.</td></tr>
<tr><td><b>variance</b></td><td>The variance of \(x - \mbox{mean}\), weighted by <span class="PFAp">w</span>.  This field is optional, but if it is provided, it must be a <span class="PFAc">double</span>, and there must be a <span class="PFApf">mean</span> as well.  No attempt is made to unbias the estimator, so multiply this by \(\mbox{count}/(\mbox{count} - 1)\) to correct for the bias due to centering on the mean.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of <span class="PFAp">state</span> with <span class="PFApf">count</span> incremented by <span class="PFAp">w</span>, <span class="PFApf">mean</span> updated to the current mean of all <span class="PFAp">x</span>, and <span class="PFApf">variance</span> updated to the current variance of all <span class="PFAp">x</span>.  If the <span class="PFAp">state</span> has fields other than <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and <span class="PFApf">variance</span>, they are copied unaltered to the output state.</td></tr>
</table></p>
</div>
<div id="fcn:stat.sample.updateCovariance" class="PFAfcndef">
{<b>"stat.sample.updateCovariance":</b> [x, w, state]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>array of double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>count</i>: double, <i>mean</i>: array of double, <i>covariance</i>: array of array of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"stat.sample.updateCovariance":</b> [x, w, state]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>map of double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>count</i>: map of map of double, <i>mean</i>: map of double, <i>covariance</i>: map of map of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a covariance calculation.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample vector, expressed as an array or map; must have at least two components.</td></tr>
<tr><td><b>w</b></td><td>Sample weight; set to 1 for no weights.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and <span class="PFApf">covariance</span>.
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>count</b></td><td>The sum of weights <span class="PFAp">w</span>.  If <span class="PFAp">x</span> is an array, then <span class="PFApf">count</span> is a single value representing the sum of weights for all records seen so far.  If <span class="PFAp">x</span> is a map, then <span class="PFApf">count</span> is a matrix in which entry \(i\), \(j\) is the sum of weights for records in which key \(i\) and key \(j\) both appear in <span class="PFAp">x</span>.</td></tr>
<tr><td><b>mean</b></td><td>The componentwise mean of <span class="PFAp">x</span>, weighted by <span class="PFAp">w</span>.</td></tr>
<tr><td><b>covariance</b></td><td>The covariance matrix of all pairs of components of <span class="PFAp">x</span>, weighted by <span class="PFAp">w</span>.  If <span class="PFAp">x</span> is an array, this matrix is represented by a list of lists.  If <span class="PFAp">x</span> is a map, this matrix is represented by a map of maps.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of <span class="PFAp">state</span> with <span class="PFApf">count</span> incremented by <span class="PFAp">w</span>, <span class="PFApf">mean</span> updated to the current componentwise mean of all <span class="PFAp">x</span>, and <span class="PFApf">covariance</span> updated to the current covariance matrix of all <span class="PFAp">x</span>.  If the <span class="PFAp">state</span> has fields other than <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and <span class="PFApf">covariance</span>, they are copied unaltered to the output state.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, indexes of <span class="PFAp">x</span> correspond to the same indexes of <span class="PFApf">mean</span> and rows and columns of <span class="PFApf">covariance</span>, where a row is an index of <span class="PFApf">covariance</span> and a column is an index of an element of <span class="PFApf">covariance</span>.  In the map signature, keys of <span class="PFAp">x</span> correspond to the same keys of <span class="PFApf">mean</span>, as well as rows and columns of <span class="PFApf">count</span> and <span class="PFApf">covariance</span>, where a row is a key of the object and a column is a key of a value of the object.  In the array signature, all arrays must have equal length (including the nested arrays within <span class="PFApf">covariance</span>) and all components are updated with each call.  In the map signature, a previously unseen key in <span class="PFAp">x</span> creates a new key in <span class="PFApf">mean</span> with value <span class="PFAp">x</span>, a new row and column in <span class="PFApf">count</span> with value <span class="PFAp">w</span> for all key pairs existing in <span class="PFAp">x</span> and zero for key pairs not in <span class="PFAp">x</span>, as well as a new row and column in <span class="PFApf">covariance</span> filled with zeros.</li><li>In the map signature, missing keys in <span class="PFAp">x</span> are equivalent to contributions with zero weight.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">state</span> is <span class="PFAc">null</span> and the record type has fields other than <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and <span class="PFApf">covariance</span>, then a "cannot initialize unrecognized fields" error is raised.  Unrecognized fields are only allowed if an initial record is provided.</li><li>If <span class="PFAp">x</span> has fewer than 2 components, a "too few components" error is raised.</li><li>If <span class="PFAp">x</span>, <span class="PFApf">mean</span>, and <span class="PFApf">covariance</span> are arrays with unequal lengths, an "unequal length arrays" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.updateWindow" class="PFAfcndef">
{<b>"stat.sample.updateWindow":</b> [x, w, state, windowSize]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>state</b></td><td>array of any record <b>A</b> with fields {<i>x</i>: double, <i>w</i>: double, <i>count</i>: double}</td></tr><tr><td><b>windowSize</b></td><td>int</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a counter, a counter and a mean, or a counter, mean, and variance, within a window of <span class="PFAp">windowSize</span> recent samples.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>w</b></td><td>Sample weight; set to 1 for no weights.</td></tr>
<tr><td><b>state</b></td><td>Array of previous <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and/or <span class="PFApf">variance</span> and samples in the window.
          
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>count</b></td><td>The sum of weights <span class="PFAp">w</span> within the window.</td></tr>
<tr><td><b>mean</b></td><td>The mean of <span class="PFAp">x</span> within the window, weighted by <span class="PFAp">w</span>.  This field is optional, but if provided, it must be a <span class="PFAc">double</span>.</td></tr>
<tr><td><b>variance</b></td><td>The variance of \(x - \mbox{mean}\) within the window, weighted by <span class="PFAp">w</span>.  This field is optional, but if it is provided, it must be a <span class="PFAc">double</span>, and there must be a <span class="PFApf">mean</span> as well.  No attempt is made to unbias the estimator, so multiply this by \(\mbox{count}/(\mbox{count} - 1)\) to correct for the bias due to centering on the mean.</td></tr>
<tr><td><b>x</b></td><td>Sample value, saved so that it can be removed from the running mean and variance when it goes out of scope.</td></tr>
<tr><td><b>w</b></td><td>Sample weight, saved for the same reason.</td></tr>
</table></td></tr>
<tr><td><b>windowSize</b></td><td>Size of the window.  When the length of <span class="PFAp">state</span> is less than <span class="PFAp">windowSize</span>, this function is equivalent to <span class="PFAf">stat.sample.update</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>If the length of <span class="PFAp">state</span> is zero, this function returns a singleton array with <span class="PFApf">count</span> = <span class="PFAp">w</span>, <span class="PFApf">mean</span> = <span class="PFAp">x</span>, and/or <span class="PFApf">variance</span> = 0.  If the length of <span class="PFAp">state</span> is less than <span class="PFAp">windowSize</span>, then it returns a copy of <span class="PFAp">state</span> with the next record added.  Otherwise, it is trunctated to <span class="PFAp">windowSize</span>, removing the old values from the running count/mean/variance.  In all cases, the <span class="PFAf">a.last</span> item is the latest result.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">windowSize</span> is less than 2, a "windowSize must be at least 2" error is raised.</li><li>If <span class="PFAp">state</span> is empty and the record type has fields other than <span class="PFApf">count</span>, <span class="PFApf">mean</span>, and <span class="PFApf">variance</span>, then a "cannot initialize unrecognized fields" error is raised.  Unrecognized fields are only allowed if an initial record is provided.</li></ul></p>
</div>
<div id="fcn:stat.sample.updateEWMA" class="PFAfcndef">
{<b>"stat.sample.updateEWMA":</b> [x, alpha, state]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>mean</i>: double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of an exponentially weighted moving average (EWMA).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>alpha</b></td><td>Weighting factor (usually a constant) between 0 and 1, inclusive.  If <span class="PFAp">alpha</span> is close to 1, recent data are heavily weighted at the expense of old data; if <span class="PFAp">alpha</span> is close to 0, the EWMA approaches a simple mean.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">mean</span> and <span class="PFApf">variance</span>.
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>mean</b></td><td>The exponentially weighted mean of <span class="PFAp">x</span>, weighted by <span class="PFAp">alpha</span>.</td></tr>
<tr><td><b>variance</b></td><td>The exponentially weighted variance of <span class="PFAp">x</span>, weighted by <span class="PFAp">alpha</span>.  This field is optional, but if provided, it must be a <span class="PFAc">double</span>.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a new record with updated <span class="PFApf">mean</span> and <span class="PFApf">variance</span>.  If the input <span class="PFAp">state</span> has fields other than <span class="PFApf">mean</span> and <span class="PFApf">variance</span>, they are copied unaltered to the output state.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">alpha</span> is less than 0 or greater than 1, an "alpha out of range" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.updateHoltWinters" class="PFAfcndef">
{<b>"stat.sample.updateHoltWinters":</b> [x, alpha, beta, state]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><b>beta</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>level</i>: double, <i>trend</i>: double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a time series analysis with an exponentially weighted linear fit.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>alpha</b></td><td>Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <span class="PFApf">level</span>.  If <span class="PFAp">alpha</span> is close to 1, recent data are heavily weighted at the expense of old data.</td></tr>
<tr><td><b>beta</b></td><td>Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <span class="PFApf">trend</span>.  If <span class="PFAp">beta</span> is close to 1, recent data are heavily weighted at the expense of old data.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">level</span> and <span class="PFApf">trend</span>.
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>level</b></td><td>The constant term in an exponentially weighted linear fit of recent data, weighted by <span class="PFAp">alpha</span>.</td></tr>
<tr><td><b>trend</b></td><td>The linear term in an exponentially weighted linear fit of recent data, weighted by <span class="PFAp">beta</span>.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of the <span class="PFAp">state</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>Use <span class="PFAf">stat.sample.forecast1HoltWinters</span> or <span class="PFAf">stat.sample.forecastHoltWinters</span> to make predictions from the state record.</li><li>For \(a_t\) = the <span class="PFApf">level</span> at a time \(t\) and \(b_t\) = the <span class="PFApf">trend</span> at a time \(t\), \(a_t = \alpha x + (1 - \alpha)(a_{t-1} + b_{t-1})\) and \(b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}\).</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">alpha</span> is less than 0 or greater than 1, an "alpha out of range" error is raised.</li><li>If <span class="PFAp">beta</span> is less than 0 or greater than 1, an "beta out of range" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.updateHoltWintersPeriodic" class="PFAfcndef">
{<b>"stat.sample.updateHoltWintersPeriodic":</b> [x, alpha, beta, gamma, state]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>alpha</b></td><td>double</td></tr><tr><td><b>beta</b></td><td>double</td></tr><tr><td><b>gamma</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>level</i>: double, <i>trend</i>: double, <i>cycle</i>: array of double, <i>multiplicative</i>: boolean}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a time series analysis with an exponentially weighted periodic-plus-linear fit.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>alpha</b></td><td>Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <span class="PFApf">level</span>.  If <span class="PFAp">alpha</span> is close to 1, recent data are heavily weighted at the expense of old data.</td></tr>
<tr><td><b>beta</b></td><td>Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <span class="PFApf">trend</span>.  If <span class="PFAp">beta</span> is close to 1, recent data are heavily weighted at the expense of old data.</td></tr>
<tr><td><b>gamma</b></td><td>Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <span class="PFApf">cycle</span>.  If <span class="PFAp">gamma</span> is close to 1, recent data are heavily weighted at the expense of old data.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">level</span>, <span class="PFApf">trend</span>, and <span class="PFApf">cycle</span>.
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>level</b></td><td>The constant term in an exponentially weighted linear fit of recent data, weighted by <span class="PFAp">alpha</span>.</td></tr>
<tr><td><b>trend</b></td><td>The linear term in an exponentially weighted linear fit of recent data, weighted by <span class="PFAp">beta</span>.</td></tr>
<tr><td><b>cycle</b></td><td>The history of the previous cycle, weighted by <span class="PFAp">gamma</span>.  If the length of this array is \(L\), then the built-in period is \(L\) time steps long.</td></tr>
<tr><td><b>multiplicative</b></td><td>If <span class="PFAc">true</span>, interpret <span class="PFApf">cycle</span> as multiplicative; if <span class="PFAc">false</span>, interpret it as additive.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of the <span class="PFAp">state</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>Use <span class="PFAf">stat.sample.forecast1HoltWinters</span> or <span class="PFAf">stat.sample.forecastHoltWinters</span> to make predictions from the state record.</li><li>For \(a_t\) = the <span class="PFApf">level</span> at a time \(t\), \(b_t\) = the <span class="PFApf">trend</span> at a time \(t\), and \(c_t\) = the <span class="PFApf">cycle</span> at a time \(t\) with period \(L\), \(a_t = \alpha x_t / c_{t-L} + (1 - \alpha)(a_{t-1} + b_{t-1})\), \(b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}\), and \(c_t = \gamma x_t / a_t + (1 - \gamma) c_{t-L}\) for the multiplicative case and \(a_t = \alpha (x_t - c_{t-L}) + (1 - \alpha)(a_{t-1} + b_{t-1})\), \(b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}\), and \(c_t = \gamma (x_t - a_t) + (1 - \gamma) c_{t-L}\) for the additive case.</li><li>In each call to this function, <span class="PFApf">cycle</span> is rotated left, such that the first item is \(c_t\).</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">alpha</span> is less than 0 or greater than 1, an "alpha out of range" error is raised.</li><li>If <span class="PFAp">beta</span> is less than 0 or greater than 1, an "beta out of range" error is raised.</li><li>If <span class="PFAp">gamm</span> is less than 0 or greater than 1, an "gamma out of range" error is raised.</li><li>If <span class="PFApf">cycle</span> is empty, an "empty cycle" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.forecast1HoltWinters" class="PFAfcndef">
{<b>"stat.sample.forecast1HoltWinters":</b> [state]} <br><table class="PFAwhere"><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>level</i>: double, <i>trend</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Forecast one time-step from a state record prepared by <span class="PFAf">stat.state.updateHoltWinters</span> or <span class="PFAf">stat.state.updateHoltWintersPeriodic</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>state</b></td><td>Record of <span class="PFApf">level</span>, <span class="PFApf">trend</span>, and possibly <span class="PFApf">cycle</span> and <span class="PFApf">multiplicative</span>.
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>level</b></td><td>The constant term in an exponentially weighted linear fit of recent data.</td></tr>
<tr><td><b>trend</b></td><td>The linear term in an exponentially weighted linear fit of recent data.</td></tr>
<tr><td><b>cycle</b></td><td>The history of the previous cycle.  This field is optional, but if provided, it must be a <span class="PFAc">double</span> and must be accompanied by <span class="PFApf">multiplicative</span>.</td></tr>
<tr><td><b>multiplicative</b></td><td>If <span class="PFAc">true</span>, interpret <span class="PFApf">cycle</span> as multiplicative; if <span class="PFAc">false</span>, interpret it as additive.  This field is optional, but if provided, it must be a <span class="PFAc">boolean</span> and must be accompanied by <span class="PFApf">cycle</span>.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a prediction of the next time-step.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>For \(a_t\) = the <span class="PFApf">level</span> at a time \(t\), \(b_t\) = the <span class="PFApf">trend</span> at a time \(t\), and \(c_t\) = the <span class="PFApf">cycle</span> at a time \(t\) with period \(L\), this function returns \(a_t + b_t\) (non-periodic), \((a_t + b_t) c_{t+1}\) (multiplicative), or \(a_t + b_t + c_{t+1}\) (additive) for each \(i\) from \(0\) to \(n - 1\)</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFApf">cycle</span> is empty, an "empty cycle" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.forecastHoltWinters" class="PFAfcndef">
{<b>"stat.sample.forecastHoltWinters":</b> [n, state]} <br><table class="PFAwhere"><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>level</i>: double, <i>trend</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
<p><b>Description:</b> Forecast <span class="PFAp">n</span> time-steps from a state record prepared by <span class="PFAf">stat.state.updateHoltWinters</span> or <span class="PFAf">stat.state.updateHoltWintersPeriodic</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>state</b></td><td>Record of <span class="PFApf">level</span>, <span class="PFApf">trend</span>, and possibly <span class="PFApf">cycle</span> and <span class="PFApf">multiplicative</span>.
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>level</b></td><td>The constant term in an exponentially weighted linear fit of recent data.</td></tr>
<tr><td><b>trend</b></td><td>The linear term in an exponentially weighted linear fit of recent data.</td></tr>
<tr><td><b>cycle</b></td><td>The history of the previous cycle.  This field is optional, but if provided, it must be a <span class="PFAc">double</span> and must be accompanied by <span class="PFApf">multiplicative</span>.</td></tr>
<tr><td><b>multiplicative</b></td><td>If <span class="PFAc">true</span>, interpret <span class="PFApf">cycle</span> as multiplicative; if <span class="PFAc">false</span>, interpret it as additive.  This field is optional, but if provided, it must be a <span class="PFAc">boolean</span> and must be accompanied by <span class="PFApf">cycle</span>.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a series of predictions for the next <span class="PFAp">n</span> time-steps.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>For \(a_t\) = the <span class="PFApf">level</span> at a time \(t\), \(b_t\) = the <span class="PFApf">trend</span> at a time \(t\), and \(c_t\) = the <span class="PFApf">cycle</span> at a time \(t\) with period \(L\), this function returns \(a_t + i b_t\) (non-periodic), \((a_t + i b_t) c_{(t + i) \mbox{mod} n}\) (multiplicative), or \(a_t + i b_t + c_{(t + i) \mbox{mod} n}\) (additive) for each \(i\) from \(1\) to \(n\)</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFApf">cycle</span> is empty, an "empty cycle" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.fillHistogram" class="PFAfcndef">
{<b>"stat.sample.fillHistogram":</b> [x, w, histogram]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>histogram</b></td><td>any record <b>A</b> with fields {<i>numbins</i>: int, <i>low</i>: double, <i>high</i>: double, <i>values</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"stat.sample.fillHistogram":</b> [x, w, histogram]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>histogram</b></td><td>any record <b>A</b> with fields {<i>low</i>: double, <i>binsize</i>: double, <i>values</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"stat.sample.fillHistogram":</b> [x, w, histogram]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>histogram</b></td><td>any record <b>A</b> with fields {<i>ranges</i>: array of array of double, <i>values</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update a histogram by filling it with one value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>w</b></td><td>Sample weight; set to 1 for no weights.</td></tr>
<tr><td><b>histogram</b></td><td>The histogram prior to filling.  It must have <span class="PFApf">numbins</span>, <span class="PFApf">low</span>, <span class="PFApf">high</span>, and <span class="PFApf">values</span> (fixed bins) xor it must have <span class="PFApf">low</span>, <span class="PFApf">binsize</span>, and <span class="PFApf">values</span> (number of equal-sized bins grows), xor it must have <span class="PFApf">ranges</span> and <span class="PFApf">values</span> (arbitrary interval bins).  Only one set of required fields is allowed (semantic error otherwise), and the rest of the fields are optional.
          
          
          
          
          
          
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>numbins</b></td><td>The fixed number of bins in the histogram.</td></tr>
<tr><td><b>low</b></td><td>The low edge of the histogram range (inclusive).</td></tr>
<tr><td><b>high</b></td><td>The high edge of the histogram range (exclusive).</td></tr>
<tr><td><b>binsize</b></td><td>The size of a bin for a histogram whose number of bins and right edge grows with the data.</td></tr>
<tr><td><b>ranges</b></td><td>Pairs of values describing arbitrary interval bins.  The first number of each pair is the inclusive left edge and the second number is the exclusive right edge.</td></tr>
<tr><td><b>values</b></td><td>Histogram contents, which are updated by this function.</td></tr>
<tr><td><b>underflow</b></td><td>If present, this double-valued field counts <span class="PFAp">x</span> values that are less than <span class="PFApf">low</span> or not contained in any <span class="PFApf">ranges</span>.</td></tr>
<tr><td><b>overflow</b></td><td>If present, this double-valued field counts <span class="PFAp">x</span> values that are greater than <span class="PFApf">high</span>.</td></tr>
<tr><td><b>nanflow</b></td><td>If present, this double-valued field counts <span class="PFAp">x</span> values that are <span class="PFAc">nan</span>.  <span class="PFAc">nan</span> values would never enter <span class="PFApf">values</span>, <span class="PFApf">underflow</span>, or <span class="PFApf">overflow</span>.</td></tr>
<tr><td><b></b></td><td>If present, this double-valued field counts <span class="PFAp">x</span> values that are infinite.  Infinite values would only enter <span class="PFApf">underflow</span> or <span class="PFApf">overflow</span> if <span class="PFApf">infflow</span> is not present, so that they are not double-counted.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of <span class="PFAp">histogram</span>: all fields are unchanged except for <span class="PFApf">values</span>, <span class="PFApf">underflow</span>, <span class="PFApf">overflow</span>, <span class="PFApf">nanflow</span>, and <span class="PFApf">infflow</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If the histogram is growable (described by <span class="PFApf">low</span> and <span class="PFApf">binsize</span>) and <span class="PFAp">x</span> minus <span class="PFApf">low</span> is greater than or equal to <span class="PFApf">binsize</span> times the length of <span class="PFApf">values</span>, the <span class="PFApf">values</span> will be padded with zeros to reach it.</li><li>If the histogram is growable (described by <span class="PFApf">low</span> and <span class="PFApf">binsize</span>), only finite values can extend the size of the histogram: infinite values are entered into <span class="PFApf">overflow</span> or <span class="PFApf">infflow</span>, depending on whether <span class="PFApf">infflow</span> is present.</li><li>If the histogram is described by <span class="PFApf">ranges</span> and an element of <span class="PFApf">ranges</span> contains two equal values, then <span class="PFAp">x</span> is considered in the interval if it is exactly equal to the value.</li><li>If the histogram is described by <span class="PFApf">ranges</span> and <span class="PFAp">x</span> falls within multiple, overlapping intervals, then all matching counters are updated (values can be double-counted).</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If the length of <span class="PFApf">values</span> is not equal to <span class="PFApf">numbins</span> or the length of <span class="PFApf">ranges</span>, then a "wrong histogram size" error is raised.</li><li>If <span class="PFApf">low</span> is greater than or equal to <span class="PFApf">high</span>, then a "bad histogram range" error is raised.</li><li>If <span class="PFApf">numbins</span> is less than 1 or <span class="PFApf">binsize</span> is equal to 0, then a "bad histogram scale" error is raised.</li><li>If <span class="PFApf">ranges</span> contains an array of doubles with length not equal to 2 or if the first element is greater than the second element, then a "bad histogram ranges" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.fillHistogram2d" class="PFAfcndef">
{<b>"stat.sample.fillHistogram2d":</b> [x, y, w, histogram]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>y</b></td><td>double</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>histogram</b></td><td>any record <b>A</b> with fields {<i>xnumbins</i>: int, <i>xlow</i>: double, <i>xhigh</i>: double, <i>ynumbins</i>: int, <i>ylow</i>: double, <i>yhigh</i>: double, <i>values</i>: array of array of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update a two-dimensional histogram by filling it with one value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample x value.</td></tr>
<tr><td><b>y</b></td><td>Sample y value.</td></tr>
<tr><td><b>w</b></td><td>Sample weight; set to 1 for no weights.</td></tr>
<tr><td><b>histogram</b></td><td>The histogram prior to filling.
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>xnumbins</b></td><td>The number of bins in the x dimension.</td></tr>
<tr><td><b>xlow</b></td><td>The low edge of the histogram range in the x dimension (inclusive).</td></tr>
<tr><td><b>xhigh</b></td><td>The high edge of the histogram range in the x dimension (exclusive).</td></tr>
<tr><td><b>ynumbins</b></td><td>The number of bins in the y dimension.</td></tr>
<tr><td><b>ylow</b></td><td>The low edge of the histogram range in the y dimension (inclusive).</td></tr>
<tr><td><b>yhigh</b></td><td>The high edge of the histogram range in the y dimension (exclusive).</td></tr>
<tr><td><b>values</b></td><td>Histogram contents, which are updated by this function.  The outer array iterates over <span class="PFAp">x</span> and the inner array iterates over <span class="PFAp">y</span>.</td></tr>
<tr><td><b>underunderflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is less than <span class="PFApf">xlow</span> and <span class="PFAp">y</span> is less than <span class="PFApf">ylow</span>.</td></tr>
<tr><td><b>undermidflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is less than <span class="PFApf">xlow</span> and <span class="PFAp">y</span> between <span class="PFApf">ylow</span> (inclusive) and <span class="PFApf">yhigh</span> (exclusive).</td></tr>
<tr><td><b>underoverflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is less than <span class="PFApf">xlow</span> and <span class="PFAp">y</span> is greater than or equal to <span class="PFApf">yhigh</span>.</td></tr>
<tr><td><b>midunderflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is between <span class="PFApf">xlow</span> (inclusive) and <span class="PFApf">xhigh</span> (exclusive) and <span class="PFAp">y</span> is less than <span class="PFApf">ylow</span>.</td></tr>
<tr><td><b>midoverflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is between <span class="PFApf">xlow</span> (inclusive) and <span class="PFApf">xhigh</span> (exclusive) and <span class="PFAp">y</span> is greater than or equal to <span class="PFApf">yhigh</span>.</td></tr>
<tr><td><b>overunderflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is greater than or equal to <span class="PFApf">xhigh</span> and <span class="PFAp">y</span> is less than <span class="PFApf">ylow</span>.</td></tr>
<tr><td><b>overmidflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is greater than or equal to <span class="PFApf">xhigh</span> and <span class="PFAp">y</span> between <span class="PFApf">ylow</span> (inclusive) and <span class="PFApf">yhigh</span> (exclusive).</td></tr>
<tr><td><b>overoverflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> is greater than or equal to <span class="PFApf">xhigh</span> and <span class="PFAp">y</span> is greater than or equal to <span class="PFApf">yhigh</span>.</td></tr>
<tr><td><b>nanflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> or <span class="PFAp">y</span> is <span class="PFAc">nan</span>.  <span class="PFAc">nan</span> values would never enter any other counter.</td></tr>
<tr><td><b>infflow</b></td><td>If present, this double-valued field counts instances in which <span class="PFAp">x</span> or <span class="PFAp">y</span> is infinite.  Infinite values would only enter the other under/mid/overflow counters if <span class="PFApf">infflow</span> were not present, so that they are not double-counted.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of <span class="PFAp">histogram</span>: all fields are unchanged except for <span class="PFApf">values</span> and the under/mid/over/nan/infflow counters.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If <span class="PFAp">x</span> is infinite and <span class="PFAp">y</span> is <span class="PFAc">nan</span> or <span class="PFAp">x</span> is <span class="PFAc">nan</span> and <span class="PFAp">y</span> is infinite, the entry is counted as <span class="PFAc">nan</span>, rather than infinite.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If the length of <span class="PFApf">values</span> is not equal to <span class="PFApf">xnumbins</span> or the length of any element of <span class="PFApf">values</span> is not equal to <span class="PFApf">ynumbins</span>, then a "wrong histogram size" error is raised.</li><li>If <span class="PFApf">xlow</span> is greater than or equal to <span class="PFApf">xhigh</span> or if <span class="PFApf">ylow</span> is greater than or equal to <span class="PFApf">yhigh</span>, then a "bad histogram range" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.sample.fillCounter" class="PFAfcndef">
{<b>"stat.sample.fillCounter":</b> [x, w, counter]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>string</td></tr><tr><td><b>w</b></td><td>double</td></tr><tr><td><b>counter</b></td><td>any record <b>A</b> with fields {<i>values</i>: map of double}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update a counter (sparse histogram) by filling it with one value.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample category.</td></tr>
<tr><td><b>w</b></td><td>Sample weight; set to 1 for no weights.</td></tr>
<tr><td><b>histogram</b></td><td>The counter prior to filling.
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>values</b></td><td>Number of instances seen of each category.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns the updated counter.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If a category is not present in the initial <span class="PFApf">values</span>, it is added with initial value zero prior to filling.</li></ul></p>
</div>
<div id="fcn:stat.sample.topN" class="PFAfcndef">
{<b>"stat.sample.topN":</b> [x, top, n, lessThan]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>any <b>A</b></td></tr><tr><td><b>top</b></td><td>array of <b>A</b></td></tr><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>lessThan</b></td><td>function of (<b>A</b>, <b>A</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>array of <b>A</b></td></tr></table>
<p><b>Description:</b> Update an array of the top <span class="PFAp">n</span> sorted items by potentially adding <span class="PFAp">x</span> to that array, using <span class="PFAp">lessThan</span> as a comparison function.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Sample value.</td></tr>
<tr><td><b>top</b></td><td>Array of items to which <span class="PFAp">x</span> might be added.  This array is assumed to be sorted according to <span class="PFAp">lessThan</span>.</td></tr>
<tr><td><b>n</b></td><td>Maximum number of items to keep.</td></tr>
<tr><td><b>lessThan</b></td><td>Comparison function; should return <span class="PFAc">true</span> if its first argument is less than its second argument, <span class="PFAc">false</span> otherwise.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an updated version of <span class="PFAp">top</span>.  If <span class="PFAp">x</span> is among the top <span class="PFAp">n</span> values seen, then it is included in the output.  Otherwise, the output is <span class="PFAp">top</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>The <span class="PFAp">x</span> value is inserted after the first element of <span class="PFAp">top</span> that it is greater than or equal to (<span class="PFAp">lessThan</span> applied to that array element and <span class="PFAp">x</span> returns <span class="PFAc">true</span>) and the result is truncated to size <span class="PFAp">n</span>.  Thus, the result only represents a top-n list if <span class="PFAp">top</span> is already sorted and equal elements already in the array get precedence.</li><li>The <span class="PFAp">top</span> array is unchanged by this function because all values in PFA are immutable.  The updated array is the return value.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:stat.change">stat.change</h2></div>
<div id="fcn:stat.change.updateTrigger" class="PFAfcndef">
{<b>"stat.change.updateTrigger":</b> [predicate, history]} <br><table class="PFAwhere"><tr><td><b>predicate</b></td><td>boolean</td></tr><tr><td><b>history</b></td><td>any record <b>A</b> with fields {<i>numEvents</i>: int, <i>numRuns</i>: int, <i>currentRun</i>: int, <i>longestRun</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a trigger that counts the number of times <span class="PFAp">predicate</span> is satisfied (<span class="PFAc">true</span>), as well as the number and lengths of runs of <span class="PFAc">true</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>predicate</b></td><td>Expression that evaluates to <span class="PFAc">true</span> or <span class="PFAc">false</span>.</td></tr>
<tr><td><b>history</b></td><td>Summary of previous results of the <span class="PFAp">predicate</span>.
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>numEvents</b></td><td>The number of times <span class="PFAp">predicate</span> evaluated to <span class="PFAc">true</span>.</td></tr>
<tr><td><b>numRuns</b></td><td>The number of contiguous intervals in which <span class="PFAp">predicate</span> was <span class="PFAc">true</span>, including the current one.</td></tr>
<tr><td><b>currentRun</b></td><td>If <span class="PFAp">predicate</span> is <span class="PFAc">false</span>, <span class="PFApf">currentRun</span> is 0.  Otherwise, <span class="PFApf">currentRun</span> is incremented (greater than or equal to 1 if <span class="PFAp">predicate</span> evaluated to <span class="PFAc">true</span>).</td></tr>
<tr><td><b>longestRun</b></td><td>The longest run observed so far; may be equal to <span class="PFApf">currentRun</span>.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a new record with updated fields: <span class="PFApf">numEvents</span> is always incremented; <span class="PFApf">numRuns</span> is incremented if <span class="PFAp">predicate</span> is <span class="PFAc">true</span> and <span class="PFApf">currentRun</span> is zero; <span class="PFApf">currentRun</span> is incremented if <span class="PFAp">predicate</span> is <span class="PFAc">true</span> and set to zero if <span class="PFAp">predicate</span> is <span class="PFAc">false</span>; <span class="PFApf">longestRun</span> is set to <span class="PFApf">currentRun</span> if <span class="PFAp">predicate</span> is <span class="PFAc">true</span> and <span class="PFApf">currentRun</span> is longer than <span class="PFApf">longestRun</span>.  If the input <span class="PFAp">history</span> has fields other than <span class="PFApf">numEvents</span>, <span class="PFApf">numRuns</span>, <span class="PFApf">currentRun</span>, or <span class="PFApf">longestRun</span>, they are copied unaltered to the output.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If any of <span class="PFApf">numEvents</span>, <span class="PFApf">numRuns</span>, <span class="PFApf">currentRun</span>, and <span class="PFApf">longestRun</span> are less than 0, a "counter out of range" error is raised.</li></ul></p>
</div>
<div id="fcn:stat.change.zValue" class="PFAfcndef">
{<b>"stat.change.zValue":</b> [x, meanVariance]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>meanVariance</b></td><td>any record <b>A</b> with fields {<i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"stat.change.zValue":</b> [x, meanVariance, unbiased]} <br><table class="PFAwhere"><tr><td><b>x</b></td><td>double</td></tr><tr><td><b>meanVariance</b></td><td>any record <b>A</b> with fields {<i>count</i>: double, <i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><b>unbiased</b></td><td>boolean</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Calculate the z-value between <span class="PFAp">x</span> and a normal distribution with a given mean and variance.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>x</b></td><td>Value to test.</td></tr>
<tr><td><b>meanVariance</b></td><td>A record with <span class="PFApf">mean</span>, <span class="PFApf">variance</span>, and possibly <span class="PFApf">count</span>, such as the output of <span class="PFAf">stat.sample.Update</span>.</td></tr>
<tr><td><b>unbiased</b></td><td>If <span class="PFAc">true</span>, use <span class="PFApf">count</span> to correct for the bias due to the fact that a variance centered on the mean has one fewer degrees of freedom than the dataset that it was sampled from (Bessel's correction).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>If <span class="PFAp">unbiased</span> is <span class="PFAc">false</span>, \((x - mean)/\sqrt{variance}\); otherwise \((x - mean)(1/\sqrt{variance})\sqrt{count/(count - 1)}\).</td></tr>
</table></p>
</div>
<div id="fcn:stat.change.updateCUSUM" class="PFAfcndef">
{<b>"stat.change.updateCUSUM":</b> [logLikelihoodRatio, last, reset]} <br><table class="PFAwhere"><tr><td><b>logLikelihoodRatio</b></td><td>double</td></tr><tr><td><b>last</b></td><td>double</td></tr><tr><td><b>reset</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Update a cumulative sum (CUSUM) to detect the transition of a dataset from one distribution to another.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>logLikelihoodRatio</b></td><td>The logarithm of the ratio of the likelihood of a value for the alterate and baseline distributions: \(\ln(\mbox{alt}_{L}/\mbox{base}_{L})\), which is \(\mbox{alt}_{LL} - \mbox{base}_{LL}\) where \(L\) is likelihood and \(LL\) is log-likelihood.  Consider using something like <span class="PFAc">{"-": [{"prob.dist.gaussianLL": [...]}, {"prob.dist.gaussianLL": [...]}]}</span>.</td></tr>
<tr><td><b>last</b></td><td>The previous return value from this function.</td></tr>
<tr><td><b>reset</b></td><td>A low value (usually consistent with the baseline hypothesis, such as 0) at which the cumulative sum resets, rather than accumulate very low values and become insensitive to future changes.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>An incremented cumulative sum.  The output is \(\max\{logLikelihoodRatio + last, reset\}\).</td></tr>
</table></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:model.reg">model.reg</h2></div>
<div id="fcn:model.reg.linear" class="PFAfcndef">
{<b>"model.reg.linear":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>coeff</i>: array of double, <i>const</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.linear":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>coeff</i>: array of array of double, <i>const</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"model.reg.linear":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>coeff</i>: map of double, <i>const</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.linear":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>coeff</i>: map of map of double, <i>const</i>: map of double}</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Apply matrix <span class="PFAp">model</span> to independent variables <span class="PFAp">datum</span> to predict the dependent, predicted variables.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Vector of independent variables with \(d\) dimensions.</td></tr>
<tr><td><b>model</b></td><td>Parameters of the linear model.
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>coeff</b></td><td>Vector or matrix of coefficients that multiply the input variables, which has \(p\) rows and \(d\) columns.</td></tr>
<tr><td><b>const</b></td><td>Scalar or vector of constant offsets, which has \(p\) dimensions.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a \(p\) dimensional vector of dependent, predicted variables.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings).</li><li>The simpler signature is may be used in the \(p = 1\)case.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned coeff" error if any row of <span class="PFApf">coeff</span> does not have the same indexes as <span class="PFAp">datum</span>.</li><li>Raises a "misaligned const" error if <span class="PFApf">const</span> does not have the same indexes as <span class="PFAp">datum</span>.</li></ul></p>
</div>
<div id="fcn:model.reg.linearVariance" class="PFAfcndef">
{<b>"model.reg.linearVariance":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>covar</i>: array of array of double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.linearVariance":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>covar</i>: array of array of array of double}</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"model.reg.linearVariance":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>covar</i>: map of map of double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.linearVariance":</b> [datum, model]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>model</b></td><td>any record <b>M</b> with fields {<i>covar</i>: map of map of map of double}</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Propagate variances from <span class="PFAp">model</span> <span class="PFApf">covar</span> (covariance matrix) to the dependent, predicted variable(s).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Vector of independent variables \(\vec{o}\) with \(d\) dimensions.</td></tr>
<tr><td><b>model</b></td><td>Parameters of the linear model.
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>covar</b></td><td>Covariance matrix \(C\) or array/map of covariance matrices, one for each dependent, predicted variable.  Each matrix has \(d + 1\) rows and \(d + 1\) columns: the last or empty string-key row and column corresponds to the model's constant term.  If there are \(p\) dependent, predicted variables, the outermost array/map has \(p\) items.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Propagated variance(s) \(\vec{o}^T C \vec{o}\) for each dependent, predicted variable.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>The "error" or "uncertainty" in the predicted variable(s) is the square root of this value/these values.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned covariance" error if any covariance matrix does not have the same indexes as <span class="PFAp">datum</span> plus the implicit index for a constant (last in array signature, empty string-key in map signature).</li></ul></p>
</div>
<div id="fcn:model.reg.residual" class="PFAfcndef">
{<b>"model.reg.residual":</b> [observation, prediciton]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.residual instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>double</td></tr><tr><td><b>prediciton</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.residual":</b> [observation, prediciton]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.residual instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>array of double</td></tr><tr><td><b>prediciton</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"model.reg.residual":</b> [observation, prediciton]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.residual instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>map of double</td></tr><tr><td><b>prediciton</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Compare an observation with its prediction by element-wise subtraction.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>observation</b></td><td>Scalar or vector of observations.</td></tr>
<tr><td><b>prediction</b></td><td>Scalar or vector of predictions.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Scalar or vector of <span class="PFAp">observation</span> minus <span class="PFAp">prediction</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned prediction" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">observation</span>.</li></ul></p>
</div>
<div id="fcn:model.reg.pull" class="PFAfcndef">
{<b>"model.reg.pull":</b> [observation, prediciton, uncertainty]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.pull instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>double</td></tr><tr><td><b>prediciton</b></td><td>double</td></tr><tr><td><b>uncertainty</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.pull":</b> [observation, prediciton, uncertainty]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.pull instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>array of double</td></tr><tr><td><b>prediciton</b></td><td>array of double</td></tr><tr><td><b>uncertainty</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"model.reg.pull":</b> [observation, prediciton, uncertainty]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.pull instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>map of double</td></tr><tr><td><b>prediciton</b></td><td>map of double</td></tr><tr><td><b>uncertainty</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>map of double</td></tr></table>
<p><b>Description:</b> Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>observation</b></td><td>Scalar or vector of observations.</td></tr>
<tr><td><b>prediction</b></td><td>Scalar or vector of predictions.</td></tr>
<tr><td><b>uncertainty</b></td><td>Scalar or vector of predictions.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Scalar or vector of <span class="PFAp">observation</span> minus <span class="PFAp">prediction</span> divided by <span class="PFAp">uncertainty</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "misaligned prediction" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">observation</span>.</li><li>Raises a "misaligned uncertainty" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">uncertainty</span>.</li></ul></p>
</div>
<div id="fcn:model.reg.mahalanobis" class="PFAfcndef">
{<b>"model.reg.mahalanobis":</b> [observation, prediction, covariance]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.mahalanobis instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>array of double</td></tr><tr><td><b>prediction</b></td><td>array of double</td></tr><tr><td><b>covariance</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.reg.mahalanobis":</b> [observation, prediction, covariance]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.mahalanobis instead<br><table class="PFAwhere"><tr><td><b>observation</b></td><td>map of double</td></tr><tr><td><b>prediction</b></td><td>map of double</td></tr><tr><td><b>covariance</b></td><td>map of map of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>observation</b></td><td>Vector of observations \(\vec{o}\).</td></tr>
<tr><td><b>prediction</b></td><td>Vector of predictions \(\vec{p}\).</td></tr>
<tr><td><b>covariance</b></td><td>Matrix of covariance \(C\).</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Scalar result of a similarity transformation: \(\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}\).</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "too few rows/cols" error if <span class="PFAp">observation</span> has fewer than one element.</li><li>Raises a "misaligned prediction" error if <span class="PFAp">prediction</span> does not have the same indexes as <span class="PFAp">observation</span>.</li><li>Raises a "misaligned covariance" error if <span class="PFAp">covariance</span> does not have the same indexes as <span class="PFAp">observation</span>.</li></ul></p>
</div>
<div id="fcn:model.reg.updateChi2" class="PFAfcndef">
{<b>"model.reg.updateChi2":</b> [pull, state]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.updateChi2 instead<br><table class="PFAwhere"><tr><td><b>pull</b></td><td>double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"model.reg.updateChi2":</b> [pull, state]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.updateChi2 instead<br><table class="PFAwhere"><tr><td><b>pull</b></td><td>array of double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
{<b>"model.reg.updateChi2":</b> [pull, state]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.updateChi2 instead<br><table class="PFAwhere"><tr><td><b>pull</b></td><td>map of double</td></tr><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td><b>A</b></td></tr></table>
<p><b>Description:</b> Update the state of a chi-square calculation.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>pull</b></td><td>Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.</td></tr>
<tr><td><b>state</b></td><td>Record of the previous <span class="PFApf">chi2</span> and <span class="PFApf">DOF</span>.</td></tr>
</table></p>
</div>
<div id="fcn:model.reg.reducedChi2" class="PFAfcndef">
{<b>"model.reg.reducedChi2":</b> [state]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.reducedChi2 instead<br><table class="PFAwhere"><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the reduced chi-square, which is <span class="PFApf">chi2</span>/<span class="PFApf">DOF</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>state</b></td><td>Record of the <span class="PFApf">chi2</span> and <span class="PFApf">DOF</span>.</td></tr>
</table></p>
</div>
<div id="fcn:model.reg.chi2Prob" class="PFAfcndef">
{<b>"model.reg.chi2Prob":</b> [state]} <span style="border: 1px solid #0e5f80; margin-right: 3px; padding: 3px;"><b>deprecated until PFA 0.9.0</b></span>use test.chi2Prob instead<br><table class="PFAwhere"><tr><td><b>state</b></td><td>any record <b>A</b> with fields {<i>chi2</i>: double, <i>DOF</i>: int}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Return the chi-square probability, which is the CDF of the chi-square function.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>state</b></td><td>Record of the <span class="PFApf">chi2</span> and <span class="PFApf">DOF</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises "invalid parameterization" if <span class="PFApf">DOF</span> is less than zero.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:model.tree">model.tree</h2></div>
<div id="fcn:model.tree.simpleTest" class="PFAfcndef">
{<b>"model.tree.simpleTest":</b> [datum, comparison]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>comparison</b></td><td>any record <b>T</b> with fields {<i>field</i>: enum <b>F</b> of fields of D, <i>operator</i>: string, <i>value</i>: any <b>V</b>}</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Determine if <span class="PFAp">datum</span> passes a test defined by <span class="PFAp">comparison</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample value to test.</td></tr>
<tr><td><b>comparison</b></td><td>Record that describes a test.
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>field</b></td><td>Field name from <span class="PFAp">datum</span>: the enumeration type must include all fields of <span class="PFAtp">D</span> in their declaration order.</td></tr>
<tr><td><b>operator</b></td><td>One of the following: "==" (equal), "!=" (not equal), "&lt;" (less than), "&lt;=" (less or equal), "&gt;" (greater than), "&gt;=" (greater or equal), "in" (member of a set), "notIn" (not a member of a set), "alwaysTrue" (ignore <span class="PFApf">value</span>, return <span class="PFAc">true</span>), "alwaysFalse" (ignore <span class="PFApf">value</span>, return <span class="PFAc">false</span>), "isMissing" (ignore <span class="PFApf">value</span>, return <span class="PFAc">true</span> iff the field of <span class="PFAp">datum</span> is <span class="PFAc">null</span>), and "notMissing" (ignore <span class="PFApf">value</span>, return <span class="PFAc">false</span> iff the field of <span class="PFAp">datum</span> is <span class="PFAc">null</span>).</td></tr>
<tr><td><b>value</b></td><td>Value to which the field of <span class="PFAp">datum</span> is compared.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns <span class="PFAc">true</span> if the field of <span class="PFAp">datum</span> &lt;op&gt; <span class="PFApf">value</span> is <span class="PFAc">true</span>, <span class="PFAc">false</span> otherwise, where &lt;op&gt; is the <span class="PFApf">operator</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid comparison operator" if <span class="PFApf">operator</span> is not one of "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "in", "notIn", "alwaysTrue", "alwaysFalse", "isMissing", "notMissing".</li><li>Raises a "bad value type" if the <span class="PFApf">field</span> of <span class="PFAp">datum</span> and <span class="PFAtp">V</span> are not both numbers and the <span class="PFApf">field</span> cannot be upcast to <span class="PFAtp">V</span>.</li></ul></p>
</div>
<div id="fcn:model.tree.missingTest" class="PFAfcndef">
{<b>"model.tree.missingTest":</b> [datum, comparison]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>comparison</b></td><td>any record <b>T</b> with fields {<i>field</i>: enum <b>F</b> of fields of D, <i>operator</i>: string, <i>value</i>: any <b>V</b>}</td></tr><tr><td><i>(returns)</i></td><td>union of {null, boolean}</td></tr></table>
<p><b>Description:</b> Determine if <span class="PFAp">datum</span> passes a test defined by <span class="PFAp">comparison</span>, allowing for missing values.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample value to test.</td></tr>
<tr><td><b>comparison</b></td><td>Record that describes a test.
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>field</b></td><td>Field name from <span class="PFAp">datum</span>: the enumeration type must include all fields of <span class="PFAtp">D</span> in their declaration order.</td></tr>
<tr><td><b>operator</b></td><td>One of the following: "==" (equal), "!=" (not equal), "&lt;" (less than), "&lt;=" (less or equal), "&gt;" (greater than), "&gt;=" (greater or equal), "in" (member of a set), "notIn" (not a member of a set), "alwaysTrue" (ignore <span class="PFApf">value</span>, return <span class="PFAc">true</span>), "alwaysFalse" (ignore <span class="PFApf">value</span>, return <span class="PFAc">false</span>).</td></tr>
<tr><td><b>value</b></td><td>Value to which the field of <span class="PFAp">datum</span> is compared.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>If the field of <span class="PFAp">datum</span> is <span class="PFAc">null</span>, this function returns <span class="PFAc">null</span> (unknown test result).  Otherwise, it returns <span class="PFAp">datum</span> field &lt;op&gt; <span class="PFApf">value</span>, where &lt;op&gt; is the <span class="PFApf">operator</span></td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid comparison operator" if <span class="PFApf">operator</span> is not one of "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "in", "notIn", "alwaysTrue", "alwaysFalse".</li><li>Raises a "bad value type" if the <span class="PFApf">field</span> of <span class="PFAp">datum</span> and <span class="PFAtp">V</span> are not both numbers and the <span class="PFApf">field</span> cannot be upcast to <span class="PFAtp">V</span>.</li></ul></p>
</div>
<div id="fcn:model.tree.compoundTest" class="PFAfcndef">
{<b>"model.tree.compoundTest":</b> [datum, operator, comparisons, test]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>operator</b></td><td>string</td></tr><tr><td><b>comparisons</b></td><td>array of any record <b>T</b></td></tr><tr><td><b>test</b></td><td>function of (<b>D</b>, <b>T</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">test</span> to an array of <span class="PFAp">comparisons</span>, returning their logical and, or, or xor, depending on <span class="PFAp">operator</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Simple value to test.</td></tr>
<tr><td><b>operator</b></td><td>If "and", return <span class="PFAc">true</span> if no <span class="PFAc">false</span> is encountered, if "or", return <span class="PFAc">true</span> if any <span class="PFAc">true</span> is encountered, and if "xor", return <span class="PFAc">true</span> if an odd number of <span class="PFAc">true</span> is encountered among the <span class="PFAp">comparisons</span>.</td></tr>
<tr><td><b>comparisons</b></td><td>Array of records that describe the tests.</td></tr>
<tr><td><b>test</b></td><td>Test function applied to each item of <span class="PFAp">comparisons</span> until the result is certain.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Logical combination of <span class="PFAp">comparisons</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If <span class="PFAp">operator</span> is "and", the <span class="PFAp">test</span> will only be applied until the first <span class="PFAc">false</span> is encountered. If <span class="PFAp">operator</span> is "or", the <span class="PFAp">test</span> will only be applied until the first <span class="PFAc">true</span> is encountered. If <span class="PFAp">operator</span> is "xor", the <span class="PFAp">test</span> will be applied to all items of <span class="PFAp">comparisons</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">operator</span> is not "and", "or", or "xor", an "unrecognized logical operator" error is raised.</li></ul></p>
</div>
<div id="fcn:model.tree.surrogateTest" class="PFAfcndef">
{<b>"model.tree.surrogateTest":</b> [datum, comparisons, missingTest]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>comparisons</b></td><td>array of any record <b>T</b></td></tr><tr><td><b>missingTest</b></td><td>function of (<b>D</b>, <b>T</b>) &rarr; union of {null, boolean}</td></tr><tr><td><i>(returns)</i></td><td>boolean</td></tr></table>
<p><b>Description:</b> Apply <span class="PFAp">missingTest</span> to an array of <span class="PFAp">comparisons</span> until one yields a non-null result.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample value to test.</td></tr>
<tr><td><b>comparisons</b></td><td>Array of records that describe the tests.</td></tr>
<tr><td><b>missingTest</b></td><td>Test function applied to each item of <span class="PFAp">comparisons</span> until one returns a non-null result.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns the value of the first test that returns <span class="PFAc">true</span> or <span class="PFAc">false</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If all tests return <span class="PFAc">null</span>, this function raises a "no successful surrogate" error.</li></ul></p>
</div>
<div id="fcn:model.tree.simpleWalk" class="PFAfcndef">
{<b>"model.tree.simpleWalk":</b> [datum, treeNode, test]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>treeNode</b></td><td>any record <b>T</b> with fields {<i>pass</i>: union of {<b>T</b>, any <b>S</b>}, <i>fail</i>: union of {<b>T</b>, <b>S</b>}}</td></tr><tr><td><b>test</b></td><td>function of (<b>D</b>, <b>T</b>) &rarr; boolean</td></tr><tr><td><i>(returns)</i></td><td><b>S</b></td></tr></table>
<p><b>Description:</b> Descend through a tree, testing the fields of <span class="PFAp">datum</span> with the <span class="PFAp">test</span> function using <span class="PFAp">treeNode</span> to define the comparison, continuing to <span class="PFApf">pass</span> or <span class="PFApf">fail</span> until reaching a leaf node of type <span class="PFAtp">S</span> (score).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample value to test.</td></tr>
<tr><td><b>treeNode</b></td><td>Node of the tree, which contains a predicate to be interpreted by <span class="PFAp">test</span>.
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>pass</b></td><td>Branch to follow if <span class="PFAp">test</span> returns <span class="PFAc">true</span>.</td></tr>
<tr><td><b>fail</b></td><td>Branch to follow if <span class="PFAp">test</span> returns <span class="PFAc">false</span>.</td></tr>
</table></td></tr>
<tr><td><b>test</b></td><td>Test function that converts <span class="PFAp">datum</span> and <span class="PFAp">treeNode</span> into <span class="PFAc">true</span> or <span class="PFAc">false</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Leaf node of type <span class="PFAtp">S</span>, which must be different from the tree nodes.  For a classification tree, <span class="PFAtp">S</span> could be a string or an enumeration set.  For a regression tree, <span class="PFAtp">S</span> would be a numerical type.  For a multivariate regression tree, <span class="PFAtp">S</span> would be an array of numbers, etc.</td></tr>
</table></p>
</div>
<div id="fcn:model.tree.missingWalk" class="PFAfcndef">
{<b>"model.tree.missingWalk":</b> [datum, treeNode, test]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>treeNode</b></td><td>any record <b>T</b> with fields {<i>pass</i>: union of {<b>T</b>, any <b>S</b>}, <i>fail</i>: union of {<b>T</b>, <b>S</b>}, <i>missing</i>: union of {<b>T</b>, <b>S</b>}}</td></tr><tr><td><b>test</b></td><td>function of (<b>D</b>, <b>T</b>) &rarr; union of {null, boolean}</td></tr><tr><td><i>(returns)</i></td><td><b>S</b></td></tr></table>
<p><b>Description:</b> Descend through a tree, testing the fields of <span class="PFAp">datum</span> with the <span class="PFAp">test</span> function using <span class="PFAp">treeNode</span> to define the comparison, continuing to <span class="PFApf">pass</span>, <span class="PFApf">fail</span>, or <span class="PFApf">missing</span> until reaching a leaf node of type <span class="PFAtp">S</span> (score).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample value to test.</td></tr>
<tr><td><b>treeNode</b></td><td>Node of the tree, which contains a predicate to be interpreted by <span class="PFAp">test</span>.
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>pass</b></td><td>Branch to follow if <span class="PFAp">test</span> returns <span class="PFAc">true</span>.</td></tr>
<tr><td><b>fail</b></td><td>Branch to follow if <span class="PFAp">test</span> returns <span class="PFAc">false</span>.</td></tr>
<tr><td><b>missing</b></td><td>Branch to follow if <span class="PFAp">test</span> returns <span class="PFAc">null</span>.</td></tr>
</table></td></tr>
<tr><td><b>test</b></td><td>Test function that converts <span class="PFAp">datum</span> and <span class="PFAp">treeNode</span> into <span class="PFAc">true</span>, <span class="PFAc">false</span>, or <span class="PFAc">null</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Leaf node of type <span class="PFAtp">S</span>, which must be different from the tree nodes.  For a classification tree, <span class="PFAtp">S</span> could be a string or an enumeration set.  For a regression tree, <span class="PFAtp">S</span> would be a numerical type.  For a multivariate regression tree, <span class="PFAtp">S</span> would be an array of numbers, etc.</td></tr>
</table></p>
</div>
<div id="fcn:model.tree.simpleTree" class="PFAfcndef">
{<b>"model.tree.simpleTree":</b> [datum, treeNode]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>any record <b>D</b></td></tr><tr><td><b>treeNode</b></td><td>any record <b>T</b> with fields {<i>field</i>: enum <b>F</b> of fields of D, <i>operator</i>: string, <i>value</i>: any <b>V</b>, <i>pass</i>: union of {<b>T</b>, any <b>S</b>}, <i>fail</i>: union of {<b>T</b>, <b>S</b>}}</td></tr><tr><td><i>(returns)</i></td><td><b>S</b></td></tr></table>
<p><b>Description:</b> Descend through a tree, testing <span class="PFAp">datum</span> with <span class="PFApf">field</span>, <span class="PFApf">operator</span>, <span class="PFApf">value</span>, following <span class="PFApf">pass</span> or <span class="PFApf">fail</span> until reaching a leaf node of type <span class="PFAtp">S</span> (score).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample value to test.</td></tr>
<tr><td><b>treeNode</b></td><td>Record that describes a tree node (predicate test with branches).
          
          
          
          
          
        </td></tr>
<tr><td></td><td><table class="PFAfields">
<tr><td><b>field</b></td><td>Field name from <span class="PFAp">datum</span>: the enumeration type must include all fields of <span class="PFAtp">D</span> in their declaration order.</td></tr>
<tr><td><b>operator</b></td><td>One of the following: "==" (equal), "!=" (not equal), "&lt;" (less than), "&lt;=" (less or equal), "&gt;" (greater than), "&gt;=" (greater or equal), "in" (member of a set), "notIn" (not a member of a set), "alwaysTrue" (ignore <span class="PFApf">value</span>, return <span class="PFAc">true</span>), "alwaysFalse" (ignore <span class="PFApf">value</span>, return <span class="PFAc">false</span>), "isMissing" (ignore <span class="PFApf">value</span>, return <span class="PFAc">true</span> iff the field of <span class="PFAp">datum</span> is <span class="PFAc">null</span>), and "notMissing" (ignore <span class="PFApf">value</span>, return <span class="PFAc">false</span> iff the field of <span class="PFAp">datum</span> is <span class="PFAc">null</span>).</td></tr>
<tr><td><b>value</b></td><td>Value to which the field of <span class="PFAp">datum</span> is compared.</td></tr>
<tr><td><b>pass</b></td><td>Branch to follow if the comparison is successful.</td></tr>
<tr><td><b>fail</b></td><td>Branch to follow if the comparison fails.</td></tr>
</table></td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Leaf node of type <span class="PFAtp">S</span>, which must be different from the tree nodes.  For a classification tree, <span class="PFAtp">S</span> could be a string or an enumeration set.  For a regression tree, <span class="PFAtp">S</span> would be a numerical type.  For a multivariate regression tree, <span class="PFAtp">S</span> would be an array of numbers, etc.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>This is a convenience function, a combination of <span class="PFAf">model.tree.simpleWalk</span> with <span class="PFAf">model.tree.simpleTest</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises an "invalid comparison operator" if <span class="PFApf">operator</span> is not one of "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "in", "notIn", "alwaysTrue", "alwaysFalse", "isMissing", "notMissing".</li><li>Raises a "bad value type" if the <span class="PFApf">field</span> of <span class="PFAp">datum</span> and <span class="PFAtp">V</span> are not both numbers and the <span class="PFApf">field</span> cannot be upcast to <span class="PFAtp">V</span>.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:model.cluster">model.cluster</h2></div>
<div id="fcn:model.cluster.closest" class="PFAfcndef">
{<b>"model.cluster.closest":</b> [datum, clusters, metric]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of any <b>A</b></td></tr><tr><td><b>clusters</b></td><td>array of any record <b>C</b> with fields {<i>center</i>: array of any <b>B</b>}</td></tr><tr><td><b>metric</b></td><td>function of (array of <b>A</b>, array of <b>B</b>) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td><b>C</b></td></tr></table>
{<b>"model.cluster.closest":</b> [datum, clusters]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>clusters</b></td><td>array of any record <b>C</b> with fields {<i>center</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td><b>C</b></td></tr></table>
<p><b>Description:</b> Find the cluster <span class="PFAtp">C</span> whose <span class="PFApf">center</span> is closest to the <span class="PFAp">datum</span>, according to the <span class="PFAp">metric</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Sample datum.</td></tr>
<tr><td><b>clusters</b></td><td>Set of clusters; the record type <span class="PFAtp">C</span> may contain additional identifying information for post-processing.</td></tr>
<tr><td><b>metric</b></td><td>Function used to compare each <span class="PFAp">datum</span> with the <span class="PFApf">center</span> of the <span class="PFAp">clusters</span>.  (See, for example, <span class="PFAf">metric.euclidean</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns the closest cluster record.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If <span class="PFAp">metric</span> is not provided, a Euclidean metric over floating point numbers is assumed.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "no clusters" error if <span class="PFAp">clusters</span> is empty.</li></ul></p>
</div>
<div id="fcn:model.cluster.closestN" class="PFAfcndef">
{<b>"model.cluster.closestN":</b> [n, datum, clusters, metric]} <br><table class="PFAwhere"><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>datum</b></td><td>array of any <b>A</b></td></tr><tr><td><b>clusters</b></td><td>array of any record <b>C</b> with fields {<i>center</i>: array of any <b>B</b>}</td></tr><tr><td><b>metric</b></td><td>function of (array of <b>A</b>, array of <b>B</b>) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of <b>C</b></td></tr></table>
{<b>"model.cluster.closestN":</b> [n, datum, clusters]} <br><table class="PFAwhere"><tr><td><b>n</b></td><td>int</td></tr><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>clusters</b></td><td>array of any record <b>C</b> with fields {<i>center</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td>array of <b>C</b></td></tr></table>
<p><b>Description:</b> Find the <span class="PFAp">n</span> clusters <span class="PFAtp">C</span> whose <span class="PFApf">centers</span> are closest to the <span class="PFAp">datum</span>, according to the <span class="PFAp">metric</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>n</b></td><td>Number of clusters to search for.</td></tr>
<tr><td><b>datum</b></td><td>Sample datum.</td></tr>
<tr><td><b>clusters</b></td><td>Set of clusters; the record type <span class="PFAtp">C</span> may contain additional identifying information for post-processing.</td></tr>
<tr><td><b>metric</b></td><td>Function used to compare each <span class="PFAp">datum</span> with the <span class="PFApf">center</span> of the <span class="PFAp">clusters</span>.  (See, for example, <span class="PFAf">metric.euclidean</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>An array of the closest cluster records in order from the closest to the farthest.  The length of the array is minimum of <span class="PFAp">n</span> and the length of <span class="PFAp">clusters</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>If <span class="PFAp">metric</span> is not provided, a Euclidean metric over floating point numbers is assumed.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">n</span> is negative, an "n must be nonnegative" error will be raised.</li></ul></p>
</div>
<div id="fcn:model.cluster.randomSeeds" class="PFAfcndef">
{<b>"model.cluster.randomSeeds":</b> [data, k, newCluster]} <br><table class="PFAwhere"><tr><td><b>data</b></td><td>array of array of any <b>A</b></td></tr><tr><td><b>k</b></td><td>int</td></tr><tr><td><b>newCluster</b></td><td>function of (int, array of <b>A</b>) &rarr; any record <b>C</b> with fields {<i>center</i>: array of any <b>B</b>}</td></tr><tr><td><i>(returns)</i></td><td>array of <b>C</b></td></tr></table>
<p><b>Description:</b> Call <span class="PFAp">newCluster</span> to create <span class="PFAp">k</span> cluster records with random, unique cluster centers drawn from <span class="PFAp">data</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>data</b></td><td>Sample data.</td></tr>
<tr><td><b>k</b></td><td>Number of times to call <span class="PFAp">newCluster</span>.</td></tr>
<tr><td><b>newCluster</b></td><td>Function that creates a cluster record, given an index (ranges from zero up to but not including <span class="PFAp">k</span>) and a random vector from <span class="PFAp">data</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>The cluster records created by <span class="PFAp">newCluster</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "k must be greater than zero" error if <span class="PFAp">k</span> is less than or equal to zero.</li><li>Raises a "not enough unique points" error if <span class="PFAp">data</span> has fewer than <span class="PFAp">k</span> unique elements.</li><li>Raises a "dimensions of vectors do not match" error if the elements of <span class="PFAp">data</span> are not all the same size.</li></ul></p>
</div>
<div id="fcn:model.cluster.kmeansIteration" class="PFAfcndef">
{<b>"model.cluster.kmeansIteration":</b> [data, clusters, metric, update]} <br><table class="PFAwhere"><tr><td><b>data</b></td><td>array of array of any <b>A</b></td></tr><tr><td><b>clusters</b></td><td>array of any record <b>C</b> with fields {<i>center</i>: array of any <b>B</b>}</td></tr><tr><td><b>metric</b></td><td>function of (array of <b>A</b>, array of <b>B</b>) &rarr; double</td></tr><tr><td><b>update</b></td><td>function of (array of array of <b>A</b>, <b>C</b>) &rarr; <b>C</b></td></tr><tr><td><i>(returns)</i></td><td>array of <b>C</b></td></tr></table>
<p><b>Description:</b> Update a cluster set by applying one iteration of k-means (Lloyd's algorithm).</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>data</b></td><td>Sample data.</td></tr>
<tr><td><b>clusters</b></td><td>Set of clusters; the record type <span class="PFAtp">C</span> may contain additional identifying information for post-processing.</td></tr>
<tr><td><b>metric</b></td><td>Function used to compare each <span class="PFAp">datum</span> with the <span class="PFApf">center</span> of the <span class="PFAp">clusters</span>.  (See, for example, <span class="PFAf">metric.euclidean</span>.)</td></tr>
<tr><td><b>update</b></td><td>Function of matched data and old cluster records that yields new cluster records.  (See, for example, <span class="PFAf">model.cluster.updateMean</span> with <span class="PFAp">weight</span> = 0.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns a new cluster set with each of the <span class="PFAtp">centers</span> located at the average of all points that match the corresponding cluster in the old cluster set.</td></tr>
</table></p>
<p><b>Details:</b><ul><li>The <span class="PFAp">update</span> function is only called if the number of matched data points is greater than zero.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "no data" error if <span class="PFAp">data</span> is empty.</li><li>Raises a "no clusters" error if <span class="PFAp">clusters</span> is empty.</li></ul></p>
</div>
<div id="fcn:model.cluster.updateMean" class="PFAfcndef">
{<b>"model.cluster.updateMean":</b> [data, cluster, weight]} <br><table class="PFAwhere"><tr><td><b>data</b></td><td>array of array of double</td></tr><tr><td><b>cluster</b></td><td>any record <b>C</b> with fields {<i>center</i>: array of double}</td></tr><tr><td><b>weight</b></td><td>double</td></tr><tr><td><i>(returns)</i></td><td><b>C</b></td></tr></table>
<p><b>Description:</b> Update a cluster record by computing the mean of the <span class="PFAp">data</span> vectors and <span class="PFAp">weight</span> times the old <span class="PFAp">cluster</span> center.</p>
<p><b>Details:</b><ul><li>If <span class="PFAp">weight</span> is zero, the new center is equal to the mean of <span class="PFAp">data</span>, ignoring the old <span class="PFAp">center</span>.</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "no data" error if <span class="PFAp">data</span> is empty.</li><li>Raises a "dimensions of vectors do not match" error if all elements of <span class="PFAp">data</span> and the <span class="PFAp">cluster</span> center do not match.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:model.neighbor">model.neighbor</h2></div>
<div id="fcn:model.neighbor.mean" class="PFAfcndef">
{<b>"model.neighbor.mean":</b> [points]} <br><table class="PFAwhere"><tr><td><b>points</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
{<b>"model.neighbor.mean":</b> [points, weight]} <br><table class="PFAwhere"><tr><td><b>points</b></td><td>array of array of double</td></tr><tr><td><b>weight</b></td><td>function of (array of double) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
<p><b>Description:</b> Return the vector-wise mean of <span class="PFAp">points</span>, possibly weighted by <span class="PFAp">weight</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>points</b></td><td>Points from a codebook, for instance from <span class="PFAf">model.neighbor.nearestK</span>.</td></tr>
<tr><td><b>weight</b></td><td>Optional weighting function from each element of <span class="PFAp">points</span> to a value.  If these values do not add up to 1.0, they will be internally normalized.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>The vector-wise mean, which is by construction within the convex hull of the <span class="PFAp">points</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">points</span> is empty, a "not enough points" error will be raised.</li><li>If the <span class="PFAp">points</span> have different sizes, an "inconsistent dimensionality" error will be raised.</li></ul></p>
</div>
<div id="fcn:model.neighbor.nearestK" class="PFAfcndef">
{<b>"model.neighbor.nearestK":</b> [k, datum, codebook, metric]} <br><table class="PFAwhere"><tr><td><b>k</b></td><td>int</td></tr><tr><td><b>datum</b></td><td>any <b>A</b></td></tr><tr><td><b>codebook</b></td><td>array of any <b>B</b></td></tr><tr><td><b>metric</b></td><td>function of (<b>A</b>, <b>B</b>) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
{<b>"model.neighbor.nearestK":</b> [k, datum, codebook]} <br><table class="PFAwhere"><tr><td><b>k</b></td><td>int</td></tr><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>codebook</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
<p><b>Description:</b> Find the <span class="PFAp">k</span> items in the <span class="PFAp">codebook</span> that are closest to the <span class="PFAp">datum</span>, according to the <span class="PFAp">metric</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>k</b></td><td>Number of <span class="PFAp">codebook</span> points to attempt to return.</td></tr>
<tr><td><b>datum</b></td><td>Sample datum.</td></tr>
<tr><td><b>codebook</b></td><td>Set of training data that is compared to the <span class="PFAp">datum</span>.</td></tr>
<tr><td><b>metric</b></td><td>Function used to compare each <span class="PFAp">datum</span> to each element of the <span class="PFAp">codebook</span>.  (See, for example, <span class="PFAf">metric.euclidean</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>An array of the closest <span class="PFAp">codebook</span> elements in any order.  The length of the array is minimum of <span class="PFAp">k</span> and the length of <span class="PFAp">codebook</span>.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>If <span class="PFAp">k</span> is negative, an "k must be nonnegative" error will be raised.</li><li>If arrays in the <span class="PFAp">codebook</span> or the <span class="PFAp">codebook</span> and the <span class="PFAp">datum</span> have different sizes (without a <span class="PFAp">metric</span>), an "inconsistent dimensionality" error will be raised.</li></ul></p>
</div>
<div id="fcn:model.neighbor.ballR" class="PFAfcndef">
{<b>"model.neighbor.ballR":</b> [r, datum, codebook, metric]} <br><table class="PFAwhere"><tr><td><b>r</b></td><td>double</td></tr><tr><td><b>datum</b></td><td>any <b>A</b></td></tr><tr><td><b>codebook</b></td><td>array of any <b>B</b></td></tr><tr><td><b>metric</b></td><td>function of (<b>A</b>, <b>B</b>) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of <b>B</b></td></tr></table>
{<b>"model.neighbor.ballR":</b> [r, datum, codebook]} <br><table class="PFAwhere"><tr><td><b>r</b></td><td>double</td></tr><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>codebook</b></td><td>array of array of double</td></tr><tr><td><i>(returns)</i></td><td>array of array of double</td></tr></table>
<p><b>Description:</b> Find the items in <span class="PFAp">codebook</span> that are within <span class="PFAp">r</span> of the <span class="PFAp">datum</span>, according to the <span class="PFAp">metric</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>r</b></td><td>Maximum distance (exclusive) of points to return.</td></tr>
<tr><td><b>datum</b></td><td>Sample datum.</td></tr>
<tr><td><b>codebook</b></td><td>Set of training data that is compared to the <span class="PFAp">datum</span>.</td></tr>
<tr><td><b>metric</b></td><td>Function used to compare each <span class="PFAp">datum</span> to each element of the <span class="PFAp">codebook</span>.  (See, for example, <span class="PFAf">metric.euclidean</span>.)</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>An array of the <span class="PFAp">codebook</span> elements within a distance <span class="PFAp">r</span> in any order.  The length of the array could be as low as zero or as high as the length of <span class="PFAp">codebook</span>.</td></tr>
</table></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:model.naive">model.naive</h2></div>
<div id="fcn:model.naive.gaussian" class="PFAfcndef">
{<b>"model.naive.gaussian":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>classModel</b></td><td>array of any record <b>A</b> with fields {<i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.naive.gaussian":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>classModel</b></td><td>map of any record <b>A</b> with fields {<i>mean</i>: double, <i>variance</i>: double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Score <span class="PFAp">datum</span> using a Gaussian Naive Bayes model.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td> Vector of independent variables with \(d\) dimensions. </td></tr>
<tr><td><b>classModel</b></td><td> Array or map of \(d\) records, each containing the <span class="PFAp">mean</span> and <span class="PFAp">variance</span> of each of independent variable, for one class. </td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns the unscaled log-likelihood that <span class="PFAp">datum</span> is a member of the class specified by <span class="PFAp">classModel</span>.</td></tr>
</table></p>
<p><b>Details:</b><ul><li><span class="PFAp">datum</span> or <span class="PFAp">classModel</span> may be expressed as arrays (indexed by integers), or maps (indexed by strings).</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "datum and classModel have different misaligned" error if <span class="PFAp">datum</span> and <span class="PFAp">classModel</span> have different lengths, of if their keys if using the map signature don't match one to one.</li><li>Raises a "variance less than or equal to zero" error if a variance inside of <span class="PFAp">classModel</span> is incorrectly specified.</li></ul></p>
</div>
<div id="fcn:model.naive.multinomial" class="PFAfcndef">
{<b>"model.naive.multinomial":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>classModel</b></td><td>array of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.naive.multinomial":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>classModel</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.naive.multinomial":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>classModel</b></td><td>any record <b>C</b> with fields {<i>values</i>: array of double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.naive.multinomial":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>map of double</td></tr><tr><td><b>classModel</b></td><td>any record <b>C</b> with fields {<i>values</i>: map of double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Score <span class="PFAp">datum</span> using a Multinomial Naive Bayes model.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Vector of independent variables with \(d\) dimensions. </td></tr>
<tr><td><b>classModel</b></td><td>Array or map of multinomial (\(d\) different) likelihoods of each independent variable for this class. The record form is for histograms built by <span class="PFAf">stat.sample.fillHistogram</span> or <span class="PFAf">stat.sample.fillCounter</span>.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns the unscaled log-likelihood of <span class="PFAp">datum</span> for this class.</td></tr>
</table></p>
<p><b>Details:</b><ul><li><span class="PFAp">datum</span> or <span class="PFAp">classModel</span> may be expressed as arrays (indexed by integers), or maps (indexed by strings).</li></ul></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "datum and classModel misaligned" error if when using the map signature the keys of <span class="PFAp">datum</span> and <span class="PFAp">classModel</span> don't match one to one, of if when using the array signature they are different lengths.</li><li>Raises a "probability in classModel cannot be less than 0, greater than 1, or when normalized return NaN" error.</li></ul></p>
</div>
<div id="fcn:model.naive.bernoulli" class="PFAfcndef">
{<b>"model.naive.bernoulli":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of string</td></tr><tr><td><b>classModel</b></td><td>map of double</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
{<b>"model.naive.bernoulli":</b> [datum, classModel]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of string</td></tr><tr><td><b>classModel</b></td><td>any record <b>C</b> with fields {<i>values</i>: map of double}</td></tr><tr><td><i>(returns)</i></td><td>double</td></tr></table>
<p><b>Description:</b> Score <span class="PFAp">datum</span> using a Bernoulli Naive Bayes model.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Vector of independent variables with \(d\) dimensions. The record form is for histograms built by <span class="PFAf">stat.sample.fillCounter</span>.</td></tr>
<tr><td><b>classModel</b></td><td>Array or map of \(d\) likelihoods of the presence of each independent variable for this class. </td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns the unscaled log-likelihood of <span class="PFAp">datum</span> for this class.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "probability in classModel cannot be less than 0 or greater than 1" error if a value in <span class="PFAp">classModel</span> is less than zero or greater than one.</li></ul></p>
</div>
<div id="lib:" class="PFAhead"><h2 id="lib:model.neural">model.neural</h2></div>
<div id="fcn:model.neural.simpleLayers" class="PFAfcndef">
{<b>"model.neural.simpleLayers":</b> [datum, model, activation]} <br><table class="PFAwhere"><tr><td><b>datum</b></td><td>array of double</td></tr><tr><td><b>model</b></td><td>array of any record <b>M</b> with fields {<i>weights</i>: array of array of double, <i>bias</i>: array of double}</td></tr><tr><td><b>activation</b></td><td>function of (double) &rarr; double</td></tr><tr><td><i>(returns)</i></td><td>array of double</td></tr></table>
<p><b>Description:</b> Apply a feedforward artificial neural network <span class="PFAp">model</span> to an input <span class="PFAp">datum</span>.</p>
<p><b>Parameters:</b><table class="PFAparams">
<tr><td><b>datum</b></td><td>Length <span class="PFAp">d</span> vector of independent variables.</td></tr>
<tr><td><b>model</b></td><td>Array containing the parameters of each layer of the feedforward neural network model.</td></tr>
<tr><td><b>activation</b></td><td>Function applied at the output of each node, except the last.  Usually an "S"-shaped sigmoid or hyperbolic tangent.</td></tr>
</table></p>
<p><b>Returns:</b><table class="PFAparams">
<tr><td>Returns an array of network outputs.  For a neural network with a single neuron in the last layer (single output), this is an array of length one.</td></tr>
</table></p>
<p><b>Runtime Errors:</b><ul><li>Raises a "no layers" error if the length of model is zero.</li><li>Raises a "weights, bias, or datum misaligned" error if there is any misalignment between inputs and outputs through the layers of the network.</li></ul></p>
</div>
